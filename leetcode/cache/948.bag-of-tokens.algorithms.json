{"id": 948, "fid": "948", "name": "令牌放置", "slug": "bag-of-tokens", "link": "https://leetcode.cn/problems/bag-of-tokens/description/", "percent": 0, "level": "Medium", "category": "algorithms", "en_name": "Bag of Tokens", "cn_name": "令牌放置", "desc": "<p>你的初始 <strong>能量</strong> 为 <code>power</code>，初始 <strong>分数</strong> 为&nbsp;<code>0</code>，只有一包令牌以整数数组&nbsp;<code>tokens</code>&nbsp;给出。其中 <code>tokens[i]</code> 是第 <code>i</code> 个令牌的值（下标从 0 开始）。</p>\n\n<p>你的目标是通过有策略地使用这些令牌以&nbsp;<strong>最大化</strong>&nbsp;总 <strong>分数</strong>。在一次行动中，你可以用两种方式中的一种来使用一个&nbsp;<strong>未被使用的</strong> 令牌（但不是对同一个令牌使用两种方式）：</p>\n\n<ul>\n\t<li><strong>朝上</strong>：如果你当前&nbsp;<strong>至少</strong> 有&nbsp;<code>tokens[i]</code>&nbsp;点 <strong>能量</strong> ，可以使用令牌 <code>i</code> ，失去&nbsp;<code>tokens[i]</code>&nbsp;点 <strong>能量</strong> ，并得到&nbsp;<code>1</code>&nbsp;<strong>分</strong> 。</li>\n\t<li><strong>朝下</strong>：如果你当前至少有&nbsp;<code>1</code>&nbsp;<strong>分 </strong>，可以使用令牌 <code>i</code> ，获得&nbsp;<code>tokens[i]</code> 点 <strong>能量</strong> ，并失去&nbsp;<code>1</code>&nbsp;<strong>分</strong> 。</li>\n</ul>\n\n<p>在使用 <strong>任意</strong> 数量的令牌后，返回我们可以得到的最大 <strong>分数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>tokens = [100], power = 50\n<strong>输出：</strong>0\n<strong>解释：</strong>因为你的初始分数为 <code>0，</code>无法使令牌朝下。你也不能使令牌朝上因为你的能量（<code>50</code>）比 <code>tokens[0]</code>&nbsp;少（<code>100</code>）。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>tokens = [200,100], power = 150\n<strong>输出：</strong>1\n<strong>解释：</strong>使令牌 1 正面朝上，能量变为 50，分数变为 1 。\n不必使用令牌 0，因为你无法使用它来提高分数。可得到的最大分数是 <code>1</code>。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>tokens = [100,200,300,400], power = 200\n<strong>输出：</strong>2\n<strong>解释：</strong>按下面顺序使用令牌可以得到 2 分：\n1. 令牌 0 (<code>100</code>)正面朝上，能量变为 <code>100</code> ，分数变为 <code>1</code>\n2. 令牌 3 (<code>400</code>)正面朝下，能量变为 <code>500</code> ，分数变为 <code>0</code>\n3. 令牌 1 (<code>200</code>)正面朝上，能量变为 <code>300</code> ，分数变为 <code>1</code>\n4. 令牌 2 (<code>300</code>)正面朝上，能量变为 <code>0</code> ，分数变为 <code>2</code>\n\n可得的最大分数是 2。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= tokens.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= tokens[i],&nbsp;power &lt; 10<sup>4</sup></code></li>\n</ul>\n", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class Solution {\npublic:\n    int bagOfTokensScore(vector<int>& tokens, int power) {\n        \n    }\n};"}, {"value": "java", "text": "Java", "defaultCode": "class Solution {\n    public int bagOfTokensScore(int[] tokens, int power) {\n        \n    }\n}"}, {"value": "python", "text": "Python", "defaultCode": "class Solution(object):\n    def bagOfTokensScore(self, tokens, power):\n        \"\"\"\n        :type tokens: List[int]\n        :type power: int\n        :rtype: int\n        \"\"\"\n        "}, {"value": "python3", "text": "Python3", "defaultCode": "class Solution:\n    def bagOfTokensScore(self, tokens: List[int], power: int) -> int:\n        "}, {"value": "c", "text": "C", "defaultCode": "int bagOfTokensScore(int* tokens, int tokensSize, int power) {\n    \n}"}, {"value": "csharp", "text": "C#", "defaultCode": "public class Solution {\n    public int BagOfTokensScore(int[] tokens, int power) {\n        \n    }\n}"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * @param {number[]} tokens\n * @param {number} power\n * @return {number}\n */\nvar bagOfTokensScore = function(tokens, power) {\n    \n};"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "function bagOfTokensScore(tokens: number[], power: number): number {\n    \n};"}, {"value": "php", "text": "PHP", "defaultCode": "class Solution {\n\n    /**\n     * @param Integer[] $tokens\n     * @param Integer $power\n     * @return Integer\n     */\n    function bagOfTokensScore($tokens, $power) {\n        \n    }\n}"}, {"value": "swift", "text": "Swift", "defaultCode": "class Solution {\n    func bagOfTokensScore(_ tokens: [Int], _ power: Int) -> Int {\n        \n    }\n}"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class Solution {\n    fun bagOfTokensScore(tokens: IntArray, power: Int): Int {\n        \n    }\n}"}, {"value": "dart", "text": "Dart", "defaultCode": "class Solution {\n  int bagOfTokensScore(List<int> tokens, int power) {\n    \n  }\n}"}, {"value": "golang", "text": "Go", "defaultCode": "func bagOfTokensScore(tokens []int, power int) int {\n    \n}"}, {"value": "ruby", "text": "Ruby", "defaultCode": "# @param {Integer[]} tokens\n# @param {Integer} power\n# @return {Integer}\ndef bag_of_tokens_score(tokens, power)\n    \nend"}, {"value": "scala", "text": "Scala", "defaultCode": "object Solution {\n    def bagOfTokensScore(tokens: Array[Int], power: Int): Int = {\n        \n    }\n}"}, {"value": "rust", "text": "Rust", "defaultCode": "impl Solution {\n    pub fn bag_of_tokens_score(tokens: Vec<i32>, power: i32) -> i32 {\n        \n    }\n}"}, {"value": "racket", "text": "Racket", "defaultCode": "(define/contract (bag-of-tokens-score tokens power)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )"}, {"value": "erlang", "text": "Erlang", "defaultCode": "-spec bag_of_tokens_score(Tokens :: [integer()], Power :: integer()) -> integer().\nbag_of_tokens_score(Tokens, Power) ->\n  ."}, {"value": "elixir", "text": "Elixir", "defaultCode": "defmodule Solution do\n  @spec bag_of_tokens_score(tokens :: [integer], power :: integer) :: integer\n  def bag_of_tokens_score(tokens, power) do\n    \n  end\nend"}, {"value": "cangjie", "text": "Cangjie", "defaultCode": "class Solution {\n    func bagOfTokensScore(tokens: Array<Int64>, power: Int64): Int64 {\n\n    }\n}"}]}