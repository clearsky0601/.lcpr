{"id": 2075, "fid": "2075", "name": "解码斜向换位密码", "slug": "decode-the-slanted-ciphertext", "link": "https://leetcode.cn/problems/decode-the-slanted-ciphertext/description/", "percent": 0, "level": "Medium", "category": "algorithms", "en_name": "Decode the Slanted Ciphertext", "cn_name": "解码斜向换位密码", "desc": "<p>字符串 <code>originalText</code> 使用 <strong>斜向换位密码</strong> ，经由 <strong>行数固定</strong> 为 <code>rows</code> 的矩阵辅助，加密得到一个字符串 <code>encodedText</code> 。</p>\n\n<p><code>originalText</code> 先按从左上到右下的方式放置到矩阵中。</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/07/exa11.png\" style=\"width: 300px; height: 185px;\" />\n<p>先填充蓝色单元格，接着是红色单元格，然后是黄色单元格，以此类推，直到到达 <code>originalText</code> 末尾。箭头指示顺序即为单元格填充顺序。所有空单元格用 <code>' '</code> 进行填充。矩阵的列数需满足：用 <code>originalText</code> 填充之后，最右侧列 <strong>不为空</strong> 。</p>\n\n<p>接着按行将字符附加到矩阵中，构造&nbsp;<code>encodedText</code> 。</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/07/exa12.png\" style=\"width: 300px; height: 200px;\" />\n<p>先把蓝色单元格中的字符附加到 <code>encodedText</code> 中，接着是红色单元格，最后是黄色单元格。箭头指示单元格访问顺序。</p>\n\n<p>例如，如果 <code>originalText = \"cipher\"</code> 且 <code>rows = 3</code> ，那么我们可以按下述方法将其编码：</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/25/desc2.png\" style=\"width: 281px; height: 211px;\" />\n<p>蓝色箭头标识 <code>originalText</code> 是如何放入矩阵中的，红色箭头标识形成 <code>encodedText</code> 的顺序。在上述例子中，<code>encodedText = \"ch&nbsp; &nbsp;ie&nbsp; &nbsp;pr\"</code> 。</p>\n\n<p>给你编码后的字符串 <code>encodedText</code> 和矩阵的行数 <code>rows</code> ，返回源字符串 <code>originalText</code> 。</p>\n\n<p><strong>注意：</strong><code>originalText</code> <strong>不</strong> 含任何尾随空格 <code>' '</code> 。生成的测试用例满足 <strong>仅存在一个</strong> 可能的 <code>originalText</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>encodedText = \"ch   ie   pr\", rows = 3\n<strong>输出：</strong>\"cipher\"\n<strong>解释：</strong>此示例与问题描述中的例子相同。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/26/exam1.png\" style=\"width: 250px; height: 168px;\" /></p>\n\n<pre>\n<strong>输入：</strong>encodedText = \"iveo    eed   l te   olc\", rows = 4\n<strong>输出：</strong>\"i love leetcode\"\n<strong>解释：</strong>上图标识用于编码 originalText 的矩阵。 \n蓝色箭头展示如何从 encodedText 找到 originalText 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/26/eg2.png\" style=\"width: 300px; height: 51px;\" /></p>\n\n<pre>\n<strong>输入：</strong>encodedText = \"coding\", rows = 1\n<strong>输出：</strong>\"coding\"\n<strong>解释：</strong>由于只有 1 行，所以 originalText 和 encodedText 是相同的。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/26/exam3.png\" style=\"width: 150px; height: 101px;\" />\n<pre>\n<strong>输入：</strong>encodedText = \" b  ac\", rows = 2\n<strong>输出：</strong>\" abc\"\n<strong>解释：</strong>originalText 不能含尾随空格，但它可能会有一个或者多个前置空格。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= encodedText.length &lt;= 10<sup>6</sup></code></li>\n\t<li><code>encodedText</code> 仅由小写英文字母和 <code>' '</code> 组成</li>\n\t<li><code>encodedText</code> 是对某个 <strong>不含</strong> 尾随空格的 <code>originalText</code> 的一个有效编码</li>\n\t<li><code>1 &lt;= rows &lt;= 1000</code></li>\n\t<li>生成的测试用例满足 <strong>仅存在一个</strong> 可能的 <code>originalText</code></li>\n</ul>\n", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class Solution {\npublic:\n    string decodeCiphertext(string encodedText, int rows) {\n        \n    }\n};"}, {"value": "java", "text": "Java", "defaultCode": "class Solution {\n    public String decodeCiphertext(String encodedText, int rows) {\n        \n    }\n}"}, {"value": "python", "text": "Python", "defaultCode": "class Solution(object):\n    def decodeCiphertext(self, encodedText, rows):\n        \"\"\"\n        :type encodedText: str\n        :type rows: int\n        :rtype: str\n        \"\"\"\n        "}, {"value": "python3", "text": "Python3", "defaultCode": "class Solution:\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\n        "}, {"value": "c", "text": "C", "defaultCode": "char* decodeCiphertext(char* encodedText, int rows) {\n    \n}"}, {"value": "csharp", "text": "C#", "defaultCode": "public class Solution {\n    public string DecodeCiphertext(string encodedText, int rows) {\n        \n    }\n}"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * @param {string} encodedText\n * @param {number} rows\n * @return {string}\n */\nvar decodeCiphertext = function(encodedText, rows) {\n    \n};"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "function decodeCiphertext(encodedText: string, rows: number): string {\n    \n};"}, {"value": "php", "text": "PHP", "defaultCode": "class Solution {\n\n    /**\n     * @param String $encodedText\n     * @param Integer $rows\n     * @return String\n     */\n    function decodeCiphertext($encodedText, $rows) {\n        \n    }\n}"}, {"value": "swift", "text": "Swift", "defaultCode": "class Solution {\n    func decodeCiphertext(_ encodedText: String, _ rows: Int) -> String {\n        \n    }\n}"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class Solution {\n    fun decodeCiphertext(encodedText: String, rows: Int): String {\n        \n    }\n}"}, {"value": "dart", "text": "Dart", "defaultCode": "class Solution {\n  String decodeCiphertext(String encodedText, int rows) {\n    \n  }\n}"}, {"value": "golang", "text": "Go", "defaultCode": "func decodeCiphertext(encodedText string, rows int) string {\n    \n}"}, {"value": "ruby", "text": "Ruby", "defaultCode": "# @param {String} encoded_text\n# @param {Integer} rows\n# @return {String}\ndef decode_ciphertext(encoded_text, rows)\n    \nend"}, {"value": "scala", "text": "Scala", "defaultCode": "object Solution {\n    def decodeCiphertext(encodedText: String, rows: Int): String = {\n        \n    }\n}"}, {"value": "rust", "text": "Rust", "defaultCode": "impl Solution {\n    pub fn decode_ciphertext(encoded_text: String, rows: i32) -> String {\n        \n    }\n}"}, {"value": "racket", "text": "Racket", "defaultCode": "(define/contract (decode-ciphertext encodedText rows)\n  (-> string? exact-integer? string?)\n  )"}, {"value": "erlang", "text": "Erlang", "defaultCode": "-spec decode_ciphertext(EncodedText :: unicode:unicode_binary(), Rows :: integer()) -> unicode:unicode_binary().\ndecode_ciphertext(EncodedText, Rows) ->\n  ."}, {"value": "elixir", "text": "Elixir", "defaultCode": "defmodule Solution do\n  @spec decode_ciphertext(encoded_text :: String.t, rows :: integer) :: String.t\n  def decode_ciphertext(encoded_text, rows) do\n    \n  end\nend"}, {"value": "cangjie", "text": "Cangjie", "defaultCode": "class Solution {\n    func decodeCiphertext(encodedText: String, rows: Int64): String {\n\n    }\n}"}]}