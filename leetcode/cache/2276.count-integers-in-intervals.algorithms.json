{"id": 2276, "fid": "2276", "name": "统计区间中的整数数目", "slug": "count-integers-in-intervals", "link": "https://leetcode.cn/problems/count-integers-in-intervals/description/", "percent": 0, "level": "Hard", "category": "algorithms", "en_name": "Count Integers in Intervals", "cn_name": "统计区间中的整数数目", "desc": "<p>给你区间的 <strong>空</strong> 集，请你设计并实现满足要求的数据结构：</p>\n\n<ul>\n\t<li><strong>新增：</strong>添加一个区间到这个区间集合中。</li>\n\t<li><strong>统计：</strong>计算出现在 <strong>至少一个</strong> 区间中的整数个数。</li>\n</ul>\n\n<p>实现 <code>CountIntervals</code> 类：</p>\n\n<ul>\n\t<li><code>CountIntervals()</code> 使用区间的空集初始化对象</li>\n\t<li><code>void add(int left, int right)</code> 添加区间 <code>[left, right]</code> 到区间集合之中。</li>\n\t<li><code>int count()</code> 返回出现在 <strong>至少一个</strong> 区间中的整数个数。</li>\n</ul>\n\n<p><strong>注意：</strong>区间 <code>[left, right]</code> 表示满足 <code>left &lt;= x &lt;= right</code> 的所有整数 <code>x</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"CountIntervals\", \"add\", \"add\", \"count\", \"add\", \"count\"]\n[[], [2, 3], [7, 10], [], [5, 8], []]\n<strong>输出</strong>\n[null, null, null, 6, null, 8]\n\n<strong>解释</strong>\nCountIntervals countIntervals = new CountIntervals(); // 用一个区间空集初始化对象\ncountIntervals.add(2, 3);  // 将 [2, 3] 添加到区间集合中\ncountIntervals.add(7, 10); // 将 [7, 10] 添加到区间集合中\ncountIntervals.count();    // 返回 6\n                           // 整数 2 和 3 出现在区间 [2, 3] 中\n                           // 整数 7、8、9、10 出现在区间 [7, 10] 中\ncountIntervals.add(5, 8);  // 将 [5, 8] 添加到区间集合中\ncountIntervals.count();    // 返回 8\n                           // 整数 2 和 3 出现在区间 [2, 3] 中\n                           // 整数 5 和 6 出现在区间 [5, 8] 中\n                           // 整数 7 和 8 出现在区间 [5, 8] 和区间 [7, 10] 中\n                           // 整数 9 和 10 出现在区间 [7, 10] 中</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= left &lt;= right &lt;= 10<sup>9</sup></code></li>\n\t<li>最多调用&nbsp; <code>add</code> 和 <code>count</code> 方法 <strong>总计</strong> <code>10<sup>5</sup></code> 次</li>\n\t<li>调用 <code>count</code> 方法至少一次</li>\n</ul>\n", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class CountIntervals {\npublic:\n    CountIntervals() {\n        \n    }\n    \n    void add(int left, int right) {\n        \n    }\n    \n    int count() {\n        \n    }\n};\n\n/**\n * Your CountIntervals object will be instantiated and called as such:\n * CountIntervals* obj = new CountIntervals();\n * obj->add(left,right);\n * int param_2 = obj->count();\n */"}, {"value": "java", "text": "Java", "defaultCode": "class CountIntervals {\n\n    public CountIntervals() {\n        \n    }\n    \n    public void add(int left, int right) {\n        \n    }\n    \n    public int count() {\n        \n    }\n}\n\n/**\n * Your CountIntervals object will be instantiated and called as such:\n * CountIntervals obj = new CountIntervals();\n * obj.add(left,right);\n * int param_2 = obj.count();\n */"}, {"value": "python", "text": "Python", "defaultCode": "class CountIntervals(object):\n\n    def __init__(self):\n        \n\n    def add(self, left, right):\n        \"\"\"\n        :type left: int\n        :type right: int\n        :rtype: None\n        \"\"\"\n        \n\n    def count(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your CountIntervals object will be instantiated and called as such:\n# obj = CountIntervals()\n# obj.add(left,right)\n# param_2 = obj.count()"}, {"value": "python3", "text": "Python3", "defaultCode": "class CountIntervals:\n\n    def __init__(self):\n        \n\n    def add(self, left: int, right: int) -> None:\n        \n\n    def count(self) -> int:\n        \n\n\n# Your CountIntervals object will be instantiated and called as such:\n# obj = CountIntervals()\n# obj.add(left,right)\n# param_2 = obj.count()"}, {"value": "c", "text": "C", "defaultCode": "\n\n\ntypedef struct {\n    \n} CountIntervals;\n\n\nCountIntervals* countIntervalsCreate() {\n    \n}\n\nvoid countIntervalsAdd(CountIntervals* obj, int left, int right) {\n    \n}\n\nint countIntervalsCount(CountIntervals* obj) {\n    \n}\n\nvoid countIntervalsFree(CountIntervals* obj) {\n    \n}\n\n/**\n * Your CountIntervals struct will be instantiated and called as such:\n * CountIntervals* obj = countIntervalsCreate();\n * countIntervalsAdd(obj, left, right);\n \n * int param_2 = countIntervalsCount(obj);\n \n * countIntervalsFree(obj);\n*/"}, {"value": "csharp", "text": "C#", "defaultCode": "public class CountIntervals {\n\n    public CountIntervals() {\n        \n    }\n    \n    public void Add(int left, int right) {\n        \n    }\n    \n    public int Count() {\n        \n    }\n}\n\n/**\n * Your CountIntervals object will be instantiated and called as such:\n * CountIntervals obj = new CountIntervals();\n * obj.Add(left,right);\n * int param_2 = obj.Count();\n */"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "\nvar CountIntervals = function() {\n    \n};\n\n/** \n * @param {number} left \n * @param {number} right\n * @return {void}\n */\nCountIntervals.prototype.add = function(left, right) {\n    \n};\n\n/**\n * @return {number}\n */\nCountIntervals.prototype.count = function() {\n    \n};\n\n/** \n * Your CountIntervals object will be instantiated and called as such:\n * var obj = new CountIntervals()\n * obj.add(left,right)\n * var param_2 = obj.count()\n */"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "class CountIntervals {\n    constructor() {\n        \n    }\n\n    add(left: number, right: number): void {\n        \n    }\n\n    count(): number {\n        \n    }\n}\n\n/**\n * Your CountIntervals object will be instantiated and called as such:\n * var obj = new CountIntervals()\n * obj.add(left,right)\n * var param_2 = obj.count()\n */"}, {"value": "php", "text": "PHP", "defaultCode": "class CountIntervals {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $left\n     * @param Integer $right\n     * @return NULL\n     */\n    function add($left, $right) {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function count() {\n        \n    }\n}\n\n/**\n * Your CountIntervals object will be instantiated and called as such:\n * $obj = CountIntervals();\n * $obj->add($left, $right);\n * $ret_2 = $obj->count();\n */"}, {"value": "swift", "text": "Swift", "defaultCode": "\nclass CountIntervals {\n\n    init() {\n        \n    }\n    \n    func add(_ left: Int, _ right: Int) {\n        \n    }\n    \n    func count() -> Int {\n        \n    }\n}\n\n/**\n * Your CountIntervals object will be instantiated and called as such:\n * let obj = CountIntervals()\n * obj.add(left, right)\n * let ret_2: Int = obj.count()\n */"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class CountIntervals() {\n\n    fun add(left: Int, right: Int) {\n        \n    }\n\n    fun count(): Int {\n        \n    }\n\n}\n\n/**\n * Your CountIntervals object will be instantiated and called as such:\n * var obj = CountIntervals()\n * obj.add(left,right)\n * var param_2 = obj.count()\n */"}, {"value": "dart", "text": "Dart", "defaultCode": "class CountIntervals {\n\n  CountIntervals() {\n    \n  }\n  \n  void add(int left, int right) {\n    \n  }\n  \n  int count() {\n    \n  }\n}\n\n/**\n * Your CountIntervals object will be instantiated and called as such:\n * CountIntervals obj = CountIntervals();\n * obj.add(left,right);\n * int param2 = obj.count();\n */"}, {"value": "golang", "text": "Go", "defaultCode": "type CountIntervals struct {\n    \n}\n\n\nfunc Constructor() CountIntervals {\n    \n}\n\n\nfunc (this *CountIntervals) Add(left int, right int)  {\n    \n}\n\n\nfunc (this *CountIntervals) Count() int {\n    \n}\n\n\n/**\n * Your CountIntervals object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Add(left,right);\n * param_2 := obj.Count();\n */"}, {"value": "ruby", "text": "Ruby", "defaultCode": "class CountIntervals\n    def initialize()\n        \n    end\n\n\n=begin\n    :type left: Integer\n    :type right: Integer\n    :rtype: Void\n=end\n    def add(left, right)\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def count()\n        \n    end\n\n\nend\n\n# Your CountIntervals object will be instantiated and called as such:\n# obj = CountIntervals.new()\n# obj.add(left, right)\n# param_2 = obj.count()"}, {"value": "scala", "text": "Scala", "defaultCode": "class CountIntervals() {\n\n    def add(left: Int, right: Int): Unit = {\n        \n    }\n\n    def count(): Int = {\n        \n    }\n\n}\n\n/**\n * Your CountIntervals object will be instantiated and called as such:\n * val obj = new CountIntervals()\n * obj.add(left,right)\n * val param_2 = obj.count()\n */"}, {"value": "rust", "text": "Rust", "defaultCode": "struct CountIntervals {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl CountIntervals {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn add(&self, left: i32, right: i32) {\n        \n    }\n    \n    fn count(&self) -> i32 {\n        \n    }\n}\n\n/**\n * Your CountIntervals object will be instantiated and called as such:\n * let obj = CountIntervals::new();\n * obj.add(left, right);\n * let ret_2: i32 = obj.count();\n */"}, {"value": "racket", "text": "Racket", "defaultCode": "(define count-intervals%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; add : exact-integer? exact-integer? -> void?\n    (define/public (add left right)\n      )\n    ; count : -> exact-integer?\n    (define/public (count)\n      )))\n\n;; Your count-intervals% object will be instantiated and called as such:\n;; (define obj (new count-intervals%))\n;; (send obj add left right)\n;; (define param_2 (send obj count))"}, {"value": "erlang", "text": "Erlang", "defaultCode": "-spec count_intervals_init_() -> any().\ncount_intervals_init_() ->\n  .\n\n-spec count_intervals_add(Left :: integer(), Right :: integer()) -> any().\ncount_intervals_add(Left, Right) ->\n  .\n\n-spec count_intervals_count() -> integer().\ncount_intervals_count() ->\n  .\n\n\n%% Your functions will be called as such:\n%% count_intervals_init_(),\n%% count_intervals_add(Left, Right),\n%% Param_2 = count_intervals_count(),\n\n%% count_intervals_init_ will be called before every test case, in which you can do some necessary initializations."}, {"value": "elixir", "text": "Elixir", "defaultCode": "defmodule CountIntervals do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec add(left :: integer, right :: integer) :: any\n  def add(left, right) do\n    \n  end\n\n  @spec count() :: integer\n  def count() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# CountIntervals.init_()\n# CountIntervals.add(left, right)\n# param_2 = CountIntervals.count()\n\n# CountIntervals.init_ will be called before every test case, in which you can do some necessary initializations."}, {"value": "cangjie", "text": "Cangjie", "defaultCode": "class CountIntervals {\n    init() {\n\n    }\n    \n    func add(left: Int64, right: Int64): Unit {\n\n    }\n    \n    func count(): Int64 {\n\n    }\n}\n\n/**\n * Your CountIntervals object will be instantiated and called as such:\n * let obj: CountIntervals = CountIntervals()\n * obj.add(left,right)\n * let param_2 = obj.count()\n */"}]}