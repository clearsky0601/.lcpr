{"id": "LCR 013", "fid": "LCR 013", "name": "二维区域和检索 - 矩阵不可变", "slug": "O4NDxx", "link": "https://leetcode.cn/problems/O4NDxx/description/", "percent": 0, "level": "Medium", "category": "algorithms", "en_name": "二维区域和检索 - 矩阵不可变", "cn_name": "二维区域和检索 - 矩阵不可变", "desc": "<p><big><small>给定一个二维矩阵 <code>matrix</code>，</small></big>以下类型的多个请求：</p>\n\n<ul>\n\t<li><big><small>计算其子矩形范围内元素的总和，该子矩阵的左上角为 <code>(row1,&nbsp;col1)</code> ，右下角为 <code>(row2,&nbsp;col2)</code> 。</small></big></li>\n</ul>\n\n<p>实现 <code>NumMatrix</code> 类：</p>\n\n<ul>\n\t<li><code>NumMatrix(int[][] matrix)</code>&nbsp;给定整数矩阵 <code>matrix</code> 进行初始化</li>\n\t<li><code>int sumRegion(int row1, int col1, int row2, int col2)</code>&nbsp;返回<big><small>左上角</small></big><big><small> <code>(row1,&nbsp;col1)</code>&nbsp;、右下角&nbsp;<code>(row2,&nbsp;col2)</code></small></big>&nbsp;的子矩阵的元素总和。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://pic.leetcode-cn.com/1626332422-wUpUHT-image.png\" style=\"width: 200px;\" /></p>\n\n<pre>\n<strong>输入:</strong> \n[&quot;NumMatrix&quot;,&quot;sumRegion&quot;,&quot;sumRegion&quot;,&quot;sumRegion&quot;]\n[[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]\n<strong>输出:</strong> \n[null, 8, 11, 12]\n\n<strong>解释:</strong>\nNumMatrix numMatrix = new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]]);\nnumMatrix.sumRegion(2, 1, 4, 3); // return 8 (红色矩形框的元素总和)\nnumMatrix.sumRegion(1, 1, 2, 2); // return 11 (绿色矩形框的元素总和)\nnumMatrix.sumRegion(1, 2, 2, 4); // return 12 (蓝色矩形框的元素总和)\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m,&nbsp;n &lt;=&nbsp;200</code><meta charset=\"UTF-8\" /></li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= matrix[i][j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= row1 &lt;= row2 &lt; m</code></li>\n\t<li><code>0 &lt;= col1 &lt;= col2 &lt; n</code></li>\n\t<li><meta charset=\"UTF-8\" />最多调用 <code>10<sup>4</sup></code> 次&nbsp;<code>sumRegion</code> 方法</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 304&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/range-sum-query-2d-immutable/\">https://leetcode-cn.com/problems/range-sum-query-2d-immutable/</a></p>\n", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class NumMatrix {\npublic:\n    NumMatrix(vector<vector<int>>& matrix) {\n        \n    }\n    \n    int sumRegion(int row1, int col1, int row2, int col2) {\n        \n    }\n};\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * NumMatrix* obj = new NumMatrix(matrix);\n * int param_1 = obj->sumRegion(row1,col1,row2,col2);\n */"}, {"value": "java", "text": "Java", "defaultCode": "class NumMatrix {\n\n    public NumMatrix(int[][] matrix) {\n        \n    }\n    \n    public int sumRegion(int row1, int col1, int row2, int col2) {\n        \n    }\n}\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * NumMatrix obj = new NumMatrix(matrix);\n * int param_1 = obj.sumRegion(row1,col1,row2,col2);\n */"}, {"value": "python", "text": "Python", "defaultCode": "class NumMatrix(object):\n\n    def __init__(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        \"\"\"\n        \n\n    def sumRegion(self, row1, col1, row2, col2):\n        \"\"\"\n        :type row1: int\n        :type col1: int\n        :type row2: int\n        :type col2: int\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your NumMatrix object will be instantiated and called as such:\n# obj = NumMatrix(matrix)\n# param_1 = obj.sumRegion(row1,col1,row2,col2)"}, {"value": "python3", "text": "Python3", "defaultCode": "class NumMatrix:\n\n    def __init__(self, matrix: List[List[int]]):\n        \n\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:\n        \n\n\n# Your NumMatrix object will be instantiated and called as such:\n# obj = NumMatrix(matrix)\n# param_1 = obj.sumRegion(row1,col1,row2,col2)"}, {"value": "c", "text": "C", "defaultCode": "\n\n\ntypedef struct {\n    \n} NumMatrix;\n\n\nNumMatrix* numMatrixCreate(int** matrix, int matrixSize, int* matrixColSize) {\n    \n}\n\nint numMatrixSumRegion(NumMatrix* obj, int row1, int col1, int row2, int col2) {\n    \n}\n\nvoid numMatrixFree(NumMatrix* obj) {\n    \n}\n\n/**\n * Your NumMatrix struct will be instantiated and called as such:\n * NumMatrix* obj = numMatrixCreate(matrix, matrixSize, matrixColSize);\n * int param_1 = numMatrixSumRegion(obj, row1, col1, row2, col2);\n \n * numMatrixFree(obj);\n*/"}, {"value": "csharp", "text": "C#", "defaultCode": "public class NumMatrix {\n\n    public NumMatrix(int[][] matrix) {\n        \n    }\n    \n    public int SumRegion(int row1, int col1, int row2, int col2) {\n        \n    }\n}\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * NumMatrix obj = new NumMatrix(matrix);\n * int param_1 = obj.SumRegion(row1,col1,row2,col2);\n */"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * @param {number[][]} matrix\n */\nvar NumMatrix = function(matrix) {\n    \n};\n\n/** \n * @param {number} row1 \n * @param {number} col1 \n * @param {number} row2 \n * @param {number} col2\n * @return {number}\n */\nNumMatrix.prototype.sumRegion = function(row1, col1, row2, col2) {\n    \n};\n\n/** \n * Your NumMatrix object will be instantiated and called as such:\n * var obj = new NumMatrix(matrix)\n * var param_1 = obj.sumRegion(row1,col1,row2,col2)\n */"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "class NumMatrix {\n    constructor(matrix: number[][]) {\n        \n    }\n\n    sumRegion(row1: number, col1: number, row2: number, col2: number): number {\n        \n    }\n}\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * var obj = new NumMatrix(matrix)\n * var param_1 = obj.sumRegion(row1,col1,row2,col2)\n */"}, {"value": "php", "text": "PHP", "defaultCode": "class NumMatrix {\n    /**\n     * @param Integer[][] $matrix\n     */\n    function __construct($matrix) {\n        \n    }\n  \n    /**\n     * @param Integer $row1\n     * @param Integer $col1\n     * @param Integer $row2\n     * @param Integer $col2\n     * @return Integer\n     */\n    function sumRegion($row1, $col1, $row2, $col2) {\n        \n    }\n}\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * $obj = NumMatrix($matrix);\n * $ret_1 = $obj->sumRegion($row1, $col1, $row2, $col2);\n */"}, {"value": "swift", "text": "Swift", "defaultCode": "\nclass NumMatrix {\n\n    init(_ matrix: [[Int]]) {\n        \n    }\n    \n    func sumRegion(_ row1: Int, _ col1: Int, _ row2: Int, _ col2: Int) -> Int {\n        \n    }\n}\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * let obj = NumMatrix(matrix)\n * let ret_1: Int = obj.sumRegion(row1, col1, row2, col2)\n */"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class NumMatrix(matrix: Array<IntArray>) {\n\n    fun sumRegion(row1: Int, col1: Int, row2: Int, col2: Int): Int {\n        \n    }\n\n}\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * var obj = NumMatrix(matrix)\n * var param_1 = obj.sumRegion(row1,col1,row2,col2)\n */"}, {"value": "dart", "text": "Dart", "defaultCode": "class NumMatrix {\n\n  NumMatrix(List<List<int>> matrix) {\n    \n  }\n  \n  int sumRegion(int row1, int col1, int row2, int col2) {\n    \n  }\n}\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * NumMatrix obj = NumMatrix(matrix);\n * int param1 = obj.sumRegion(row1,col1,row2,col2);\n */"}, {"value": "golang", "text": "Go", "defaultCode": "type NumMatrix struct {\n    \n}\n\n\nfunc Constructor(matrix [][]int) NumMatrix {\n    \n}\n\n\nfunc (this *NumMatrix) SumRegion(row1 int, col1 int, row2 int, col2 int) int {\n    \n}\n\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * obj := Constructor(matrix);\n * param_1 := obj.SumRegion(row1,col1,row2,col2);\n */"}, {"value": "ruby", "text": "Ruby", "defaultCode": "class NumMatrix\n\n=begin\n    :type matrix: Integer[][]\n=end\n    def initialize(matrix)\n        \n    end\n\n\n=begin\n    :type row1: Integer\n    :type col1: Integer\n    :type row2: Integer\n    :type col2: Integer\n    :rtype: Integer\n=end\n    def sum_region(row1, col1, row2, col2)\n        \n    end\n\n\nend\n\n# Your NumMatrix object will be instantiated and called as such:\n# obj = NumMatrix.new(matrix)\n# param_1 = obj.sum_region(row1, col1, row2, col2)"}, {"value": "scala", "text": "Scala", "defaultCode": "class NumMatrix(_matrix: Array[Array[Int]]) {\n\n    def sumRegion(row1: Int, col1: Int, row2: Int, col2: Int): Int = {\n        \n    }\n\n}\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * val obj = new NumMatrix(matrix)\n * val param_1 = obj.sumRegion(row1,col1,row2,col2)\n */"}, {"value": "rust", "text": "Rust", "defaultCode": "struct NumMatrix {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl NumMatrix {\n\n    fn new(matrix: Vec<Vec<i32>>) -> Self {\n        \n    }\n    \n    fn sum_region(&self, row1: i32, col1: i32, row2: i32, col2: i32) -> i32 {\n        \n    }\n}\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * let obj = NumMatrix::new(matrix);\n * let ret_1: i32 = obj.sum_region(row1, col1, row2, col2);\n */"}, {"value": "racket", "text": "Racket", "defaultCode": "(define num-matrix%\n  (class object%\n    (super-new)\n    \n    ; matrix : (listof (listof exact-integer?))\n    (init-field\n      matrix)\n    \n    ; sum-region : exact-integer? exact-integer? exact-integer? exact-integer? -> exact-integer?\n    (define/public (sum-region row1 col1 row2 col2)\n      )))\n\n;; Your num-matrix% object will be instantiated and called as such:\n;; (define obj (new num-matrix% [matrix matrix]))\n;; (define param_1 (send obj sum-region row1 col1 row2 col2))"}, {"value": "erlang", "text": "Erlang", "defaultCode": "-spec num_matrix_init_(Matrix :: [[integer()]]) -> any().\nnum_matrix_init_(Matrix) ->\n  .\n\n-spec num_matrix_sum_region(Row1 :: integer(), Col1 :: integer(), Row2 :: integer(), Col2 :: integer()) -> integer().\nnum_matrix_sum_region(Row1, Col1, Row2, Col2) ->\n  .\n\n\n%% Your functions will be called as such:\n%% num_matrix_init_(Matrix),\n%% Param_1 = num_matrix_sum_region(Row1, Col1, Row2, Col2),\n\n%% num_matrix_init_ will be called before every test case, in which you can do some necessary initializations."}, {"value": "elixir", "text": "Elixir", "defaultCode": "defmodule NumMatrix do\n  @spec init_(matrix :: [[integer]]) :: any\n  def init_(matrix) do\n    \n  end\n\n  @spec sum_region(row1 :: integer, col1 :: integer, row2 :: integer, col2 :: integer) :: integer\n  def sum_region(row1, col1, row2, col2) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# NumMatrix.init_(matrix)\n# param_1 = NumMatrix.sum_region(row1, col1, row2, col2)\n\n# NumMatrix.init_ will be called before every test case, in which you can do some necessary initializations."}]}