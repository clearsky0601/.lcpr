{"id": 2925, "fid": "2925", "name": "在树上执行操作以后得到的最大分数", "slug": "maximum-score-after-applying-operations-on-a-tree", "link": "https://leetcode.cn/problems/maximum-score-after-applying-operations-on-a-tree/description/", "percent": 0, "level": "Medium", "category": "algorithms", "en_name": "Maximum Score After Applying Operations on a Tree", "cn_name": "在树上执行操作以后得到的最大分数", "desc": "<p>有一棵 <code>n</code>&nbsp;个节点的无向树，节点编号为 <code>0</code>&nbsp;到 <code>n - 1</code>&nbsp;，根节点编号为 <code>0</code>&nbsp;。给你一个长度为 <code>n - 1</code>&nbsp;的二维整数数组&nbsp;<code>edges</code>&nbsp;表示这棵树，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示树中节点&nbsp;<code>a<sub>i</sub></code>&nbsp;和&nbsp;<code>b<sub>i</sub></code>&nbsp;有一条边。</p>\n\n<p>同时给你一个长度为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>values</code>&nbsp;，其中&nbsp;<code>values[i]</code>&nbsp;表示第 <code>i</code>&nbsp;个节点的值。</p>\n\n<p>一开始你的分数为 <code>0</code>&nbsp;，每次操作中，你将执行：</p>\n\n<ul>\n\t<li>选择节点&nbsp;<code>i</code>&nbsp;。</li>\n\t<li>将&nbsp;<code>values[i]</code>&nbsp;加入你的分数。</li>\n\t<li>将&nbsp;<code>values[i]</code>&nbsp;变为&nbsp;<code>0</code>&nbsp;。</li>\n</ul>\n\n<p>如果从根节点出发，到任意叶子节点经过的路径上的节点值之和都不等于 0 ，那么我们称这棵树是 <strong>健康的</strong>&nbsp;。</p>\n\n<p>你可以对这棵树执行任意次操作，但要求执行完所有操作以后树是&nbsp;<strong>健康的</strong>&nbsp;，请你返回你可以获得的 <strong>最大分数</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/10/11/graph-13-1.png\" style=\"width: 515px; height: 443px;\" /></p>\n\n<pre>\n<b>输入：</b>edges = [[0,1],[0,2],[0,3],[2,4],[4,5]], values = [5,2,5,2,1,1]\n<b>输出：</b>11\n<b>解释：</b>我们可以选择节点 1 ，2 ，3 ，4 和 5 。根节点的值是非 0 的。所以从根出发到任意叶子节点路径上节点值之和都不为 0 。所以树是健康的。你的得分之和为 values[1] + values[2] + values[3] + values[4] + values[5] = 11 。\n11 是你对树执行任意次操作以后可以获得的最大得分之和。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/10/11/graph-14-2.png\" style=\"width: 522px; height: 245px;\" /></p>\n\n<pre>\n<b>输入：</b>edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], values = [20,10,9,7,4,3,5]\n<b>输出：</b>40\n<b>解释：</b>我们选择节点 0 ，2 ，3 和 4 。\n- 从 0 到 4 的节点值之和为 10 。\n- 从 0 到 3 的节点值之和为 10 。\n- 从 0 到 5 的节点值之和为 3 。\n- 从 0 到 6 的节点值之和为 5 。\n所以树是健康的。你的得分之和为 values[0] + values[2] + values[3] + values[4] = 40 。\n40 是你对树执行任意次操作以后可以获得的最大得分之和。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>values.length == n</code></li>\n\t<li><code>1 &lt;= values[i] &lt;= 10<sup>9</sup></code></li>\n\t<li>输入保证&nbsp;<code>edges</code>&nbsp;构成一棵合法的树。</li>\n</ul>\n", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class Solution {\npublic:\n    long long maximumScoreAfterOperations(vector<vector<int>>& edges, vector<int>& values) {\n        \n    }\n};"}, {"value": "java", "text": "Java", "defaultCode": "class Solution {\n    public long maximumScoreAfterOperations(int[][] edges, int[] values) {\n        \n    }\n}"}, {"value": "python", "text": "Python", "defaultCode": "class Solution(object):\n    def maximumScoreAfterOperations(self, edges, values):\n        \"\"\"\n        :type edges: List[List[int]]\n        :type values: List[int]\n        :rtype: int\n        \"\"\"\n        "}, {"value": "python3", "text": "Python3", "defaultCode": "class Solution:\n    def maximumScoreAfterOperations(self, edges: List[List[int]], values: List[int]) -> int:\n        "}, {"value": "c", "text": "C", "defaultCode": "long long maximumScoreAfterOperations(int** edges, int edgesSize, int* edgesColSize, int* values, int valuesSize) {\n    \n}"}, {"value": "csharp", "text": "C#", "defaultCode": "public class Solution {\n    public long MaximumScoreAfterOperations(int[][] edges, int[] values) {\n        \n    }\n}"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * @param {number[][]} edges\n * @param {number[]} values\n * @return {number}\n */\nvar maximumScoreAfterOperations = function(edges, values) {\n    \n};"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "function maximumScoreAfterOperations(edges: number[][], values: number[]): number {\n    \n};"}, {"value": "php", "text": "PHP", "defaultCode": "class Solution {\n\n    /**\n     * @param Integer[][] $edges\n     * @param Integer[] $values\n     * @return Integer\n     */\n    function maximumScoreAfterOperations($edges, $values) {\n        \n    }\n}"}, {"value": "swift", "text": "Swift", "defaultCode": "class Solution {\n    func maximumScoreAfterOperations(_ edges: [[Int]], _ values: [Int]) -> Int {\n        \n    }\n}"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class Solution {\n    fun maximumScoreAfterOperations(edges: Array<IntArray>, values: IntArray): Long {\n        \n    }\n}"}, {"value": "dart", "text": "Dart", "defaultCode": "class Solution {\n  int maximumScoreAfterOperations(List<List<int>> edges, List<int> values) {\n    \n  }\n}"}, {"value": "golang", "text": "Go", "defaultCode": "func maximumScoreAfterOperations(edges [][]int, values []int) int64 {\n    \n}"}, {"value": "ruby", "text": "Ruby", "defaultCode": "# @param {Integer[][]} edges\n# @param {Integer[]} values\n# @return {Integer}\ndef maximum_score_after_operations(edges, values)\n    \nend"}, {"value": "scala", "text": "Scala", "defaultCode": "object Solution {\n    def maximumScoreAfterOperations(edges: Array[Array[Int]], values: Array[Int]): Long = {\n        \n    }\n}"}, {"value": "rust", "text": "Rust", "defaultCode": "impl Solution {\n    pub fn maximum_score_after_operations(edges: Vec<Vec<i32>>, values: Vec<i32>) -> i64 {\n        \n    }\n}"}, {"value": "racket", "text": "Racket", "defaultCode": "(define/contract (maximum-score-after-operations edges values)\n  (-> (listof (listof exact-integer?)) (listof exact-integer?) exact-integer?)\n  )"}, {"value": "erlang", "text": "Erlang", "defaultCode": "-spec maximum_score_after_operations(Edges :: [[integer()]], Values :: [integer()]) -> integer().\nmaximum_score_after_operations(Edges, Values) ->\n  ."}, {"value": "elixir", "text": "Elixir", "defaultCode": "defmodule Solution do\n  @spec maximum_score_after_operations(edges :: [[integer]], values :: [integer]) :: integer\n  def maximum_score_after_operations(edges, values) do\n    \n  end\nend"}, {"value": "cangjie", "text": "Cangjie", "defaultCode": "class Solution {\n    func maximumScoreAfterOperations(edges: Array<Array<Int64>>, values: Array<Int64>): Int64 {\n\n    }\n}"}]}