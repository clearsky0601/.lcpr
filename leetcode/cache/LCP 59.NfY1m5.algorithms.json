{"id": "LCP 59", "fid": "LCP 59", "name": "搭桥过河", "slug": "NfY1m5", "link": "https://leetcode.cn/problems/NfY1m5/description/", "percent": 0, "level": "Hard", "category": "algorithms", "en_name": "搭桥过河", "cn_name": "搭桥过河", "desc": "欢迎各位勇者来到力扣城，本次试炼主题为「搭桥过河」。\n\n勇者面前有一段长度为 `num` 的河流，河流可以划分为若干河道。每条河道上恰有一块浮木，`wood[i]` 记录了第 `i` 条河道上的浮木初始的覆盖范围。\n\n- 当且仅当浮木与相邻河道的浮木覆盖范围有重叠时，勇者才可以在两条浮木间移动\n- 勇者 **仅能在岸上** 通过花费一点「自然之力」，使任意一条浮木沿着河流移动一个单位距离\n\n请问勇者跨越这条河流，最少需要花费多少「自然之力」。\n\n\n**示例 1：**\n> 输入： `num = 10, wood = [[1,2],[4,7],[8,9]]`\n> 输出： `3`\n> 解释：如下图所示，\n> 将 [1,2] 浮木移动至 [3,4]，花费 2「自然之力」，\n> 将 [8,9] 浮木移动至 [7,8]，花费 1「自然之力」，\n> 此时勇者可以顺着 [3,4]->[4,7]->[7,8] 跨越河流，\n> 因此，勇者最少需要花费 3 点「自然之力」跨越这条河流\n![wood (2).gif](https://pic.leetcode-cn.com/1648196478-ophADL-wood%20\\(2\\).gif){:width=650px}\n\n\n**示例 2：**\n> 输入： `num = 10, wood = [[1,5],[1,1],[10,10],[6,7],[7,8]]`\n> 输出： `10`\n> 解释：\n> 将 [1,5] 浮木移动至 [2,6]，花费 1「自然之力」，\n> 将 [1,1] 浮木移动至 [6,6]，花费 5「自然之力」，\n> 将 [10,10] 浮木移动至 [6,6]，花费 4「自然之力」，\n> 此时勇者可以顺着 [2,6]->[6,6]->[6,6]->[6,7]->[7,8] 跨越河流，\n> 因此，勇者最少需要花费 10 点「自然之力」跨越这条河流\n\n\n**示例 3：**\n> 输入： `num = 5, wood = [[1,2],[2,4]]`\n> 输出： `0`\n> 解释：勇者不需要移动浮木，仍可以跨越这条河流\n\n**提示:**\n- `1 <= num <= 10^9`\n- `1 <= wood.length <= 10^5`\n- `wood[i].length == 2`\n- `1 <= wood[i][0] <= wood[i][1] <= num`\n\n", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class Solution {\npublic:\n    long long buildBridge(int num, vector<vector<int>>& wood) {\n\n    }\n};"}, {"value": "java", "text": "Java", "defaultCode": "class Solution {\n    public long buildBridge(int num, int[][] wood) {\n\n    }\n}"}, {"value": "python", "text": "Python", "defaultCode": "class Solution(object):\n    def buildBridge(self, num, wood):\n        \"\"\"\n        :type num: int\n        :type wood: List[List[int]]\n        :rtype: int\n        \"\"\""}, {"value": "python3", "text": "Python3", "defaultCode": "class Solution:\n    def buildBridge(self, num: int, wood: List[List[int]]) -> int:"}, {"value": "c", "text": "C", "defaultCode": "\n\nlong long buildBridge(int num, int** wood, int woodSize, int* woodColSize){\n\n}"}, {"value": "csharp", "text": "C#", "defaultCode": "public class Solution {\n    public long BuildBridge(int num, int[][] wood) {\n\n    }\n}"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * @param {number} num\n * @param {number[][]} wood\n * @return {number}\n */\nvar buildBridge = function(num, wood) {\n\n};"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "function buildBridge(num: number, wood: number[][]): number {\n\n};"}, {"value": "php", "text": "PHP", "defaultCode": "class Solution {\n\n    /**\n     * @param Integer $num\n     * @param Integer[][] $wood\n     * @return Integer\n     */\n    function buildBridge($num, $wood) {\n\n    }\n}"}, {"value": "swift", "text": "Swift", "defaultCode": "class Solution {\n    func buildBridge(_ num: Int, _ wood: [[Int]]) -> Int {\n\n    }\n}"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class Solution {\n    fun buildBridge(num: Int, wood: Array<IntArray>): Long {\n\n    }\n}"}, {"value": "golang", "text": "Go", "defaultCode": "func buildBridge(num int, wood [][]int) int64 {\n\n}"}, {"value": "ruby", "text": "Ruby", "defaultCode": "# @param {Integer} num\n# @param {Integer[][]} wood\n# @return {Integer}\ndef build_bridge(num, wood)\n\nend"}, {"value": "scala", "text": "Scala", "defaultCode": "object Solution {\n    def buildBridge(num: Int, wood: Array[Array[Int]]): Long = {\n\n    }\n}"}, {"value": "rust", "text": "Rust", "defaultCode": "impl Solution {\n    pub fn build_bridge(num: i32, wood: Vec<Vec<i32>>) -> i64 {\n\n    }\n}"}, {"value": "racket", "text": "Racket", "defaultCode": "(define/contract (build-bridge num wood)\n  (-> exact-integer? (listof (listof exact-integer?)) exact-integer?)\n\n  )"}, {"value": "erlang", "text": "Erlang", "defaultCode": "-spec build_bridge(Num :: integer(), Wood :: [[integer()]]) -> integer().\nbuild_bridge(Num, Wood) ->\n  ."}, {"value": "elixir", "text": "Elixir", "defaultCode": "defmodule Solution do\n  @spec build_bridge(num :: integer, wood :: [[integer]]) :: integer\n  def build_bridge(num, wood) do\n\n  end\nend"}]}