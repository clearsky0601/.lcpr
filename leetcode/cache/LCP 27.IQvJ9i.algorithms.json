{"id": "LCP 27", "fid": "LCP 27", "name": "黑盒光线反射", "slug": "IQvJ9i", "link": "https://leetcode.cn/problems/IQvJ9i/description/", "percent": 0, "level": "Hard", "category": "algorithms", "en_name": "黑盒光线反射", "cn_name": "黑盒光线反射", "desc": "秋日市集上有个奇怪的黑盒，黑盒的主视图为 n\\*m 的矩形。从黑盒的主视图来看，黑盒的上面和下面各均匀分布有 m 个小孔，黑盒的左面和右面各均匀分布有 n 个小孔。黑盒左上角小孔序号为 0，按顺时针编号，总共有 2*(m+n) 个小孔。每个小孔均可以打开或者关闭，初始时，所有小孔均处于关闭状态。每个小孔上的盖子均为镜面材质。例如一个 2\\*3 的黑盒主视图与其小孔分布如图所示:\n\n![image.png](https://pic.leetcode-cn.com/1598951281-ZCBrif-image.png){:height=\"200px\"}\n\n店长告诉小扣，这里是「几何学的快问快答」，店长可能有两种操作：\n\n- `open(int index, int direction)` - 若小孔处于关闭状态，则打开小孔，照入光线；否则直接照入光线；\n- `close(int index)` - 关闭处于打开状态小孔，店长保证不会关闭已处于关闭状态的小孔；\n\n其中：\n- `index`： 表示小孔序号\n- `direction`：`1` 表示光线沿 $y=x$ 方向，`-1` 表示光线沿 $y=-x$ 方向。\n\n![image.png](https://pic.leetcode-cn.com/1599620810-HdOlMi-image.png){:height=\"200px\"}\n\n\n当光线照至边界时：若边界上的小孔为开启状态，则光线会射出；否则，光线会在小孔之间进行反射。特别地：\n1. 若光线射向未打开的拐角（黑盒顶点），则光线会原路反射回去；\n2. 光线自拐角处的小孔照入时，只有一种入射方向（如自序号为 0 的小孔照入方向只能为 `-1`）\n\n![image.png](https://pic.leetcode-cn.com/1598953840-DLiAsf-image.png){:height=\"200px\"}\n\n请帮助小扣判断并返回店长每次照入的光线从几号小孔射出。\n\n\n**示例 1：**\n>输入：\n>`[\"BlackBox\",\"open\",\"open\",\"open\",\"close\",\"open\"]`\n>`[[2,3],[6,-1],[4,-1],[0,-1],[6],[0,-1]]`\n>\n>输出：`[null,6,4,6,null,4]`\n>\n>解释：\n>BlackBox b = BlackBox(2,3); // 新建一个 2x3 的黑盒\n>b.open(6,-1) // 打开 6 号小孔，并沿 y=-x 方向照入光线，光线至 0 号小孔反射，从 6 号小孔射出\n>b.open(4,-1) // 打开 4 号小孔，并沿 y=-x 方向照入光线，光线轨迹为 4-2-8-2-4，从 4 号小孔射出\n>b.open(0,-1) // 打开 0 号小孔，并沿 y=-x 方向照入光线，由于 6 号小孔为开启状态，光线从 6 号小孔射出\n>b.close(6) // 关闭 6 号小孔\n>b.shoot(0,-1) // 从 0 号小孔沿 y=-x 方向照入光线，由于 6 号小孔为关闭状态，4 号小孔为开启状态，光线轨迹为 0-6-4，从 4 号小孔射出\n\n**示例 2：**\n>输入：\n>`[\"BlackBox\",\"open\",\"open\",\"open\",\"open\",\"close\",\"open\",\"close\",\"open\"]`\n>`[[3,3],[1,-1],[5,1],[11,-1],[11,1],[1],[11,1],[5],[11,-1]]`\n>\n>输出：`[null,1,1,5,1,null,5,null,11]`\n>\n>解释：\n>\n>![image.png](https://pic.leetcode-cn.com/1599204202-yGDMVk-image.png){:height=\"300px\"}\n>\n>BlackBox b = BlackBox(3,3); // 新建一个 3x3 的黑盒\n>b.open(1,-1) // 打开 1 号小孔，并沿 y=-x 方向照入光线，光线轨迹为 1-5-7-11-1，从 1 号小孔射出\n>b.open(5,1) // 打开 5 号小孔，并沿 y=x 方向照入光线，光线轨迹为 5-7-11-1，从 1 号小孔射出\n>b.open(11,-1) // 打开 11 号小孔，并沿逆 y=-x 方向照入光线，光线轨迹为 11-7-5，从 5 号小孔射出\n>b.open(11,1) // 从 11 号小孔沿 y=x 方向照入光线，光线轨迹为 11-1，从 1 号小孔射出\n>b.close(1) // 关闭 1 号小孔\n>b.open(11,1) // 从 11 号小孔沿 y=x 方向照入光线，光线轨迹为 11-1-5，从 5 号小孔射出\n>b.close(5) // 关闭 5 号小孔\n>b.open(11,-1) // 从 11 号小孔沿 y=-x 方向照入光线，光线轨迹为 11-1-5-7-11，从 11 号小孔射出\n\n\n\n**提示：**\n- `1 <= n, m <= 10000`\n- `1 <= 操作次数 <= 10000`\n- `direction` 仅为 `1` 或 `-1`\n- `0 <= index < 2*(m+n)`\n", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class BlackBox {\npublic:\n    BlackBox(int n, int m) {\n\n    }\n    \n    int open(int index, int direction) {\n\n    }\n    \n    void close(int index) {\n\n    }\n};\n\n/**\n * Your BlackBox object will be instantiated and called as such:\n * BlackBox* obj = new BlackBox(n, m);\n * int param_1 = obj->open(index,direction);\n * obj->close(index);\n */"}, {"value": "java", "text": "Java", "defaultCode": "class BlackBox {\n\n    public BlackBox(int n, int m) {\n\n    }\n    \n    public int open(int index, int direction) {\n\n    }\n    \n    public void close(int index) {\n\n    }\n}\n\n/**\n * Your BlackBox object will be instantiated and called as such:\n * BlackBox obj = new BlackBox(n, m);\n * int param_1 = obj.open(index,direction);\n * obj.close(index);\n */"}, {"value": "python", "text": "Python", "defaultCode": "class BlackBox(object):\n\n    def __init__(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        \"\"\"\n\n\n    def open(self, index, direction):\n        \"\"\"\n        :type index: int\n        :type direction: int\n        :rtype: int\n        \"\"\"\n\n\n    def close(self, index):\n        \"\"\"\n        :type index: int\n        :rtype: None\n        \"\"\"\n\n\n\n# Your BlackBox object will be instantiated and called as such:\n# obj = BlackBox(n, m)\n# param_1 = obj.open(index,direction)\n# obj.close(index)"}, {"value": "python3", "text": "Python3", "defaultCode": "class BlackBox:\n\n    def __init__(self, n: int, m: int):\n\n\n    def open(self, index: int, direction: int) -> int:\n\n\n    def close(self, index: int) -> None:\n\n\n\n# Your BlackBox object will be instantiated and called as such:\n# obj = BlackBox(n, m)\n# param_1 = obj.open(index,direction)\n# obj.close(index)"}, {"value": "c", "text": "C", "defaultCode": "\n\n\ntypedef struct {\n\n} BlackBox;\n\n\nBlackBox* blackBoxCreate(int n, int m) {\n\n}\n\nint blackBoxOpen(BlackBox* obj, int index, int direction) {\n\n}\n\nvoid blackBoxClose(BlackBox* obj, int index) {\n\n}\n\nvoid blackBoxFree(BlackBox* obj) {\n\n}\n\n/**\n * Your BlackBox struct will be instantiated and called as such:\n * BlackBox* obj = blackBoxCreate(n, m);\n * int param_1 = blackBoxOpen(obj, index, direction);\n \n * blackBoxClose(obj, index);\n \n * blackBoxFree(obj);\n*/"}, {"value": "csharp", "text": "C#", "defaultCode": "public class BlackBox {\n\n    public BlackBox(int n, int m) {\n\n    }\n    \n    public int Open(int index, int direction) {\n\n    }\n    \n    public void Close(int index) {\n\n    }\n}\n\n/**\n * Your BlackBox object will be instantiated and called as such:\n * BlackBox obj = new BlackBox(n, m);\n * int param_1 = obj.Open(index,direction);\n * obj.Close(index);\n */"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * @param {number} n\n * @param {number} m\n */\nvar BlackBox = function(n, m) {\n\n};\n\n/** \n * @param {number} index \n * @param {number} direction\n * @return {number}\n */\nBlackBox.prototype.open = function(index, direction) {\n\n};\n\n/** \n * @param {number} index\n * @return {void}\n */\nBlackBox.prototype.close = function(index) {\n\n};\n\n/**\n * Your BlackBox object will be instantiated and called as such:\n * var obj = new BlackBox(n, m)\n * var param_1 = obj.open(index,direction)\n * obj.close(index)\n */"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "class BlackBox {\n    constructor(n: number, m: number) {\n\n    }\n\n    open(index: number, direction: number): number {\n\n    }\n\n    close(index: number): void {\n\n    }\n}\n\n/**\n * Your BlackBox object will be instantiated and called as such:\n * var obj = new BlackBox(n, m)\n * var param_1 = obj.open(index,direction)\n * obj.close(index)\n */"}, {"value": "php", "text": "PHP", "defaultCode": "class BlackBox {\n    /**\n     * @param Integer $n\n     * @param Integer $m\n     */\n    function __construct($n, $m) {\n\n    }\n\n    /**\n     * @param Integer $index\n     * @param Integer $direction\n     * @return Integer\n     */\n    function open($index, $direction) {\n\n    }\n\n    /**\n     * @param Integer $index\n     * @return NULL\n     */\n    function close($index) {\n\n    }\n}\n\n/**\n * Your BlackBox object will be instantiated and called as such:\n * $obj = BlackBox($n, $m);\n * $ret_1 = $obj->open($index, $direction);\n * $obj->close($index);\n */"}, {"value": "swift", "text": "Swift", "defaultCode": "\nclass BlackBox {\n\n    init(_ n: Int, _ m: Int) {\n\n    }\n    \n    func open(_ index: Int, _ direction: Int) -> Int {\n\n    }\n    \n    func close(_ index: Int) {\n\n    }\n}\n\n/**\n * Your BlackBox object will be instantiated and called as such:\n * let obj = BlackBox(n, m)\n * let ret_1: Int = obj.open(index, direction)\n * obj.close(index)\n */"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class BlackBox(n: Int, m: Int) {\n\n    fun open(index: Int, direction: Int): Int {\n\n    }\n\n    fun close(index: Int) {\n\n    }\n\n}\n\n/**\n * Your BlackBox object will be instantiated and called as such:\n * var obj = BlackBox(n, m)\n * var param_1 = obj.open(index,direction)\n * obj.close(index)\n */"}, {"value": "golang", "text": "Go", "defaultCode": "type BlackBox struct {\n\n}\n\n\nfunc Constructor(n int, m int) BlackBox {\n\n}\n\n\nfunc (this *BlackBox) Open(index int, direction int) int {\n\n}\n\n\nfunc (this *BlackBox) Close(index int)  {\n\n}\n\n\n/**\n * Your BlackBox object will be instantiated and called as such:\n * obj := Constructor(n, m);\n * param_1 := obj.Open(index,direction);\n * obj.Close(index);\n */"}, {"value": "ruby", "text": "Ruby", "defaultCode": "class BlackBox\n\n=begin\n    :type n: Integer\n    :type m: Integer\n=end\n    def initialize(n, m)\n\n    end\n\n\n=begin\n    :type index: Integer\n    :type direction: Integer\n    :rtype: Integer\n=end\n    def open(index, direction)\n\n    end\n\n\n=begin\n    :type index: Integer\n    :rtype: Void\n=end\n    def close(index)\n\n    end\n\n\nend\n\n# Your BlackBox object will be instantiated and called as such:\n# obj = BlackBox.new(n, m)\n# param_1 = obj.open(index, direction)\n# obj.close(index)"}, {"value": "scala", "text": "Scala", "defaultCode": "class BlackBox(_n: Int, _m: Int) {\n\n    def open(index: Int, direction: Int): Int = {\n\n    }\n\n    def close(index: Int) {\n\n    }\n\n}\n\n/**\n * Your BlackBox object will be instantiated and called as such:\n * var obj = new BlackBox(n, m)\n * var param_1 = obj.open(index,direction)\n * obj.close(index)\n */"}, {"value": "rust", "text": "Rust", "defaultCode": "struct BlackBox {\n\n}\n\n\n/**\n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl BlackBox {\n\n    fn new(n: i32, m: i32) -> Self {\n\n    }\n    \n    fn open(&self, index: i32, direction: i32) -> i32 {\n\n    }\n    \n    fn close(&self, index: i32) {\n\n    }\n}\n\n/**\n * Your BlackBox object will be instantiated and called as such:\n * let obj = BlackBox::new(n, m);\n * let ret_1: i32 = obj.open(index, direction);\n * obj.close(index);\n */"}]}