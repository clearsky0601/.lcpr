{"id": 2849, "fid": "2849", "name": "判断能否在给定时间到达单元格", "slug": "determine-if-a-cell-is-reachable-at-a-given-time", "link": "https://leetcode.cn/problems/determine-if-a-cell-is-reachable-at-a-given-time/description/", "percent": 0, "level": "Medium", "category": "algorithms", "en_name": "Determine if a Cell Is Reachable at a Given Time", "cn_name": "判断能否在给定时间到达单元格", "desc": "<p>给你四个整数 <code>sx</code>、<code>sy</code>、<code>fx</code>、<code>fy</code>&nbsp; 以及一个 <strong>非负整数</strong> <code>t</code> 。</p>\n\n<p>在一个无限的二维网格中，你从单元格 <code>(sx, sy)</code> 开始出发。每一秒，你 <strong>必须</strong> 移动到任一与之前所处单元格相邻的单元格中。</p>\n\n<p>如果你能在 <strong>恰好 </strong><code>t</code><strong> 秒</strong> 后到达单元格<em> </em><code>(fx, fy)</code> ，返回 <code>true</code> ；否则，返回&nbsp; <code>false</code> 。</p>\n\n<p>单元格的 <strong>相邻单元格</strong> 是指该单元格周围与其至少共享一个角的 8 个单元格。你可以多次访问同一个单元格。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/08/05/example2.svg\" style=\"width: 443px; height: 243px;\" />\n<pre>\n<strong>输入：</strong>sx = 2, sy = 4, fx = 7, fy = 7, t = 6\n<strong>输出：</strong>true\n<strong>解释：</strong>从单元格 (2, 4) 开始出发，穿过上图标注的单元格，可以在恰好 6 秒后到达单元格 (7, 7) 。 \n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/08/05/example1.svg\" style=\"width: 383px; height: 202px;\" />\n<pre>\n<strong>输入：</strong>sx = 3, sy = 1, fx = 7, fy = 3, t = 3\n<strong>输出：</strong>false\n<strong>解释：</strong>从单元格 (3, 1) 开始出发，穿过上图标注的单元格，至少需要 4 秒后到达单元格 (7, 3) 。 因此，无法在 3 秒后到达单元格 (7, 3) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sx, sy, fx, fy &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= t &lt;= 10<sup>9</sup></code></li>\n</ul>\n", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class Solution {\npublic:\n    bool isReachableAtTime(int sx, int sy, int fx, int fy, int t) {\n        \n    }\n};"}, {"value": "java", "text": "Java", "defaultCode": "class Solution {\n    public boolean isReachableAtTime(int sx, int sy, int fx, int fy, int t) {\n        \n    }\n}"}, {"value": "python", "text": "Python", "defaultCode": "class Solution(object):\n    def isReachableAtTime(self, sx, sy, fx, fy, t):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type fx: int\n        :type fy: int\n        :type t: int\n        :rtype: bool\n        \"\"\"\n        "}, {"value": "python3", "text": "Python3", "defaultCode": "class Solution:\n    def isReachableAtTime(self, sx: int, sy: int, fx: int, fy: int, t: int) -> bool:\n        "}, {"value": "c", "text": "C", "defaultCode": "bool isReachableAtTime(int sx, int sy, int fx, int fy, int t) {\n    \n}"}, {"value": "csharp", "text": "C#", "defaultCode": "public class Solution {\n    public bool IsReachableAtTime(int sx, int sy, int fx, int fy, int t) {\n        \n    }\n}"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * @param {number} sx\n * @param {number} sy\n * @param {number} fx\n * @param {number} fy\n * @param {number} t\n * @return {boolean}\n */\nvar isReachableAtTime = function(sx, sy, fx, fy, t) {\n    \n};"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "function isReachableAtTime(sx: number, sy: number, fx: number, fy: number, t: number): boolean {\n    \n};"}, {"value": "php", "text": "PHP", "defaultCode": "class Solution {\n\n    /**\n     * @param Integer $sx\n     * @param Integer $sy\n     * @param Integer $fx\n     * @param Integer $fy\n     * @param Integer $t\n     * @return Boolean\n     */\n    function isReachableAtTime($sx, $sy, $fx, $fy, $t) {\n        \n    }\n}"}, {"value": "swift", "text": "Swift", "defaultCode": "class Solution {\n    func isReachableAtTime(_ sx: Int, _ sy: Int, _ fx: Int, _ fy: Int, _ t: Int) -> Bool {\n        \n    }\n}"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class Solution {\n    fun isReachableAtTime(sx: Int, sy: Int, fx: Int, fy: Int, t: Int): Boolean {\n        \n    }\n}"}, {"value": "dart", "text": "Dart", "defaultCode": "class Solution {\n  bool isReachableAtTime(int sx, int sy, int fx, int fy, int t) {\n    \n  }\n}"}, {"value": "golang", "text": "Go", "defaultCode": "func isReachableAtTime(sx int, sy int, fx int, fy int, t int) bool {\n    \n}"}, {"value": "ruby", "text": "Ruby", "defaultCode": "# @param {Integer} sx\n# @param {Integer} sy\n# @param {Integer} fx\n# @param {Integer} fy\n# @param {Integer} t\n# @return {Boolean}\ndef is_reachable_at_time(sx, sy, fx, fy, t)\n    \nend"}, {"value": "scala", "text": "Scala", "defaultCode": "object Solution {\n    def isReachableAtTime(sx: Int, sy: Int, fx: Int, fy: Int, t: Int): Boolean = {\n        \n    }\n}"}, {"value": "rust", "text": "Rust", "defaultCode": "impl Solution {\n    pub fn is_reachable_at_time(sx: i32, sy: i32, fx: i32, fy: i32, t: i32) -> bool {\n        \n    }\n}"}, {"value": "racket", "text": "Racket", "defaultCode": "(define/contract (is-reachable-at-time sx sy fx fy t)\n  (-> exact-integer? exact-integer? exact-integer? exact-integer? exact-integer? boolean?)\n  )"}, {"value": "erlang", "text": "Erlang", "defaultCode": "-spec is_reachable_at_time(Sx :: integer(), Sy :: integer(), Fx :: integer(), Fy :: integer(), T :: integer()) -> boolean().\nis_reachable_at_time(Sx, Sy, Fx, Fy, T) ->\n  ."}, {"value": "elixir", "text": "Elixir", "defaultCode": "defmodule Solution do\n  @spec is_reachable_at_time(sx :: integer, sy :: integer, fx :: integer, fy :: integer, t :: integer) :: boolean\n  def is_reachable_at_time(sx, sy, fx, fy, t) do\n    \n  end\nend"}, {"value": "cangjie", "text": "Cangjie", "defaultCode": "class Solution {\n    func isReachableAtTime(sx: Int64, sy: Int64, fx: Int64, fy: Int64, t: Int64): Bool {\n\n    }\n}"}]}