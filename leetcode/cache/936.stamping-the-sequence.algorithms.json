{"id": 936, "fid": "936", "name": "戳印序列", "slug": "stamping-the-sequence", "link": "https://leetcode.cn/problems/stamping-the-sequence/description/", "percent": 0, "level": "Hard", "category": "algorithms", "en_name": "Stamping The Sequence", "cn_name": "戳印序列", "desc": "<p>你想要用<strong>小写字母</strong>组成一个目标字符串&nbsp;<code>target</code>。&nbsp;</p>\n\n<p>开始的时候，序列由&nbsp;<code>target.length</code>&nbsp;个&nbsp;<code>&#39;?&#39;</code>&nbsp;记号组成。而你有一个小写字母印章&nbsp;<code>stamp</code>。</p>\n\n<p>在每个回合，你可以将印章放在序列上，并将序列中的每个字母替换为印章上的相应字母。你最多可以进行&nbsp;<code>10 * target.length</code>&nbsp; 个回合。</p>\n\n<p>举个例子，如果初始序列为 &quot;?????&quot;，而你的印章 <code>stamp</code>&nbsp;是&nbsp;<code>&quot;abc&quot;</code>，那么在第一回合，你可以得到&nbsp;&quot;abc??&quot;、&quot;?abc?&quot;、&quot;??abc&quot;。（请注意，印章必须完全包含在序列的边界内才能盖下去。）</p>\n\n<p>如果可以印出序列，那么返回一个数组，该数组由每个回合中被印下的最左边字母的索引组成。如果不能印出序列，就返回一个空数组。</p>\n\n<p>例如，如果序列是 &quot;ababc&quot;，印章是 <code>&quot;abc&quot;</code>，那么我们就可以返回与操作&nbsp;&quot;?????&quot; -&gt; &quot;abc??&quot; -&gt; &quot;ababc&quot; 相对应的答案 <code>[0, 2]</code>；</p>\n\n<p>另外，如果可以印出序列，那么需要保证可以在 <code>10 * target.length</code>&nbsp;个回合内完成。任何超过此数字的答案将不被接受。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>stamp = &quot;abc&quot;, target = &quot;ababc&quot;\n<strong>输出：</strong>[0,2]\n（[1,0,2] 以及其他一些可能的结果也将作为答案被接受）\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>stamp = &quot;abca&quot;, target = &quot;aabcaca&quot;\n<strong>输出：</strong>[3,0,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= stamp.length &lt;= target.length &lt;= 1000</code></li>\n\t<li><code>stamp</code> 和&nbsp;<code>target</code>&nbsp;只包含小写字母。</li>\n</ol>\n", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class Solution {\npublic:\n    vector<int> movesToStamp(string stamp, string target) {\n        \n    }\n};"}, {"value": "java", "text": "Java", "defaultCode": "class Solution {\n    public int[] movesToStamp(String stamp, String target) {\n        \n    }\n}"}, {"value": "python", "text": "Python", "defaultCode": "class Solution(object):\n    def movesToStamp(self, stamp, target):\n        \"\"\"\n        :type stamp: str\n        :type target: str\n        :rtype: List[int]\n        \"\"\"\n        "}, {"value": "python3", "text": "Python3", "defaultCode": "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        "}, {"value": "c", "text": "C", "defaultCode": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* movesToStamp(char* stamp, char* target, int* returnSize) {\n    \n}"}, {"value": "csharp", "text": "C#", "defaultCode": "public class Solution {\n    public int[] MovesToStamp(string stamp, string target) {\n        \n    }\n}"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * @param {string} stamp\n * @param {string} target\n * @return {number[]}\n */\nvar movesToStamp = function(stamp, target) {\n    \n};"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "function movesToStamp(stamp: string, target: string): number[] {\n    \n};"}, {"value": "php", "text": "PHP", "defaultCode": "class Solution {\n\n    /**\n     * @param String $stamp\n     * @param String $target\n     * @return Integer[]\n     */\n    function movesToStamp($stamp, $target) {\n        \n    }\n}"}, {"value": "swift", "text": "Swift", "defaultCode": "class Solution {\n    func movesToStamp(_ stamp: String, _ target: String) -> [Int] {\n        \n    }\n}"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class Solution {\n    fun movesToStamp(stamp: String, target: String): IntArray {\n        \n    }\n}"}, {"value": "dart", "text": "Dart", "defaultCode": "class Solution {\n  List<int> movesToStamp(String stamp, String target) {\n    \n  }\n}"}, {"value": "golang", "text": "Go", "defaultCode": "func movesToStamp(stamp string, target string) []int {\n    \n}"}, {"value": "ruby", "text": "Ruby", "defaultCode": "# @param {String} stamp\n# @param {String} target\n# @return {Integer[]}\ndef moves_to_stamp(stamp, target)\n    \nend"}, {"value": "scala", "text": "Scala", "defaultCode": "object Solution {\n    def movesToStamp(stamp: String, target: String): Array[Int] = {\n        \n    }\n}"}, {"value": "rust", "text": "Rust", "defaultCode": "impl Solution {\n    pub fn moves_to_stamp(stamp: String, target: String) -> Vec<i32> {\n        \n    }\n}"}, {"value": "racket", "text": "Racket", "defaultCode": "(define/contract (moves-to-stamp stamp target)\n  (-> string? string? (listof exact-integer?))\n  )"}, {"value": "erlang", "text": "Erlang", "defaultCode": "-spec moves_to_stamp(Stamp :: unicode:unicode_binary(), Target :: unicode:unicode_binary()) -> [integer()].\nmoves_to_stamp(Stamp, Target) ->\n  ."}, {"value": "elixir", "text": "Elixir", "defaultCode": "defmodule Solution do\n  @spec moves_to_stamp(stamp :: String.t, target :: String.t) :: [integer]\n  def moves_to_stamp(stamp, target) do\n    \n  end\nend"}, {"value": "cangjie", "text": "Cangjie", "defaultCode": "class Solution {\n    func movesToStamp(stamp: String, target: String): Array<Int64> {\n\n    }\n}"}]}