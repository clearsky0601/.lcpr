{"id": 2721, "fid": "2721", "name": "并行执行异步函数", "slug": "execute-asynchronous-functions-in-parallel", "link": "https://leetcode.cn/problems/execute-asynchronous-functions-in-parallel/description/", "percent": 0, "level": "Medium", "category": "algorithms", "en_name": "Execute Asynchronous Functions in Parallel", "cn_name": "并行执行异步函数", "desc": "<p>给定一个异步函数数组 <code>functions</code>，返回一个新的 promise 对象&nbsp;<code>promise</code>。数组中的每个函数都不接受参数并返回一个 promise。所有的 promise 都应该并行执行。</p>\n\n<p><code>promise</code> resolve 条件：</p>\n\n<ul>\n\t<li>当所有从 <code>functions</code> 返回的 promise 都成功的并行解析时。<code>promise</code> 的解析值应该是一个按照它们在 <code>functions</code> 中的顺序排列的 promise 的解析值数组。<code>promise</code> 应该在数组中的所有异步函数并行执行完成时解析。</li>\n</ul>\n\n<p><code>promise</code>&nbsp;reject 条件：</p>\n\n<ul>\n\t<li>当任何从 <code>functions</code> 返回的 promise 被拒绝时。<code>promise</code> 也会被拒绝，并返回第一个拒绝的原因。</li>\n</ul>\n\n<p>请在不使用内置的 <code>Promise.all</code> 函数的情况下解决。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>functions = [\n&nbsp; () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(5), 200))\n]\n<b>输出：</b>{\"t\": 200, \"resolved\": [5]}\n<b>解释：</b>\npromiseAll(functions).then(console.log); // [5]\n\n单个函数在 200 毫秒后以值 5 成功解析。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>functions = [\n    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(1), 200)), \n    () =&gt; new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(\"Error\"), 100))\n]\n<b>输出：</b>{\"t\": 100, \"rejected\": \"Error\"}\n<b>解释：</b>由于其中一个 promise 被拒绝，返回的 promise 也在同一时间被拒绝并返回相同的错误。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>functions = [\n    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(4), 50)), \n    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(10), 150)), \n    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(16), 100))\n]\n<b>输出：</b>{\"t\": 150, \"resolved\": [4, 10, 16]}\n<b>解释：</b>所有的 promise 都成功执行。当最后一个 promise 被解析时，返回的 promise 也被解析了。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>函数 <code>functions</code> 是一个返回 promise 的函数数组</li>\n\t<li><code>1 &lt;= functions.length &lt;= 10</code></li>\n</ul>\n", "templates": [{"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * @param {Array<Function>} functions\n * @return {Promise<any>}\n */\nvar promiseAll = function(functions) {\n    \n};\n\n/**\n * const promise = promiseAll([() => new Promise(res => res(42))])\n * promise.then(console.log); // [42]\n */"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "type Fn<T> = () => Promise<T>\n\nfunction promiseAll<T>(functions: Fn<T>[]): Promise<T[]> {\n    \n};\n\n/**\n * const promise = promiseAll([() => new Promise(res => res(42))])\n * promise.then(console.log); // [42]\n */"}]}