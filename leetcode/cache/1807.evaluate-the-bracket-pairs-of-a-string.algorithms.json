{"id": 1807, "fid": "1807", "name": "替换字符串中的括号内容", "slug": "evaluate-the-bracket-pairs-of-a-string", "link": "https://leetcode.cn/problems/evaluate-the-bracket-pairs-of-a-string/description/", "percent": 0, "level": "Medium", "category": "algorithms", "en_name": "Evaluate the Bracket Pairs of a String", "cn_name": "替换字符串中的括号内容", "desc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，它包含一些括号对，每个括号中包含一个 <strong>非空</strong>&nbsp;的键。</p>\n\n<ul>\n\t<li>比方说，字符串&nbsp;<code>\"(name)is(age)yearsold\"</code>&nbsp;中，有&nbsp;<strong>两个</strong>&nbsp;括号对，分别包含键&nbsp;<code>\"name\"</code> 和&nbsp;<code>\"age\"</code>&nbsp;。</li>\n</ul>\n\n<p>你知道许多键对应的值，这些关系由二维字符串数组&nbsp;<code>knowledge</code>&nbsp;表示，其中&nbsp;<code>knowledge[i] = [key<sub>i</sub>, value<sub>i</sub>]</code>&nbsp;，表示键&nbsp;<code>key<sub>i</sub></code>&nbsp;对应的值为&nbsp;<code>value<sub>i</sub></code><sub>&nbsp;</sub>。</p>\n\n<p>你需要替换 <strong>所有</strong>&nbsp;的括号对。当你替换一个括号对，且它包含的键为&nbsp;<code>key<sub>i</sub></code>&nbsp;时，你需要：</p>\n\n<ul>\n\t<li>将&nbsp;<code>key<sub>i</sub></code>&nbsp;和括号用对应的值&nbsp;<code>value<sub>i</sub></code>&nbsp;替换。</li>\n\t<li>如果从 <code>knowledge</code>&nbsp;中无法得知某个键对应的值，你需要将&nbsp;<code>key<sub>i</sub></code>&nbsp;和括号用问号&nbsp;<code>\"?\"</code>&nbsp;替换（不需要引号）。</li>\n</ul>\n\n<p><code>knowledge</code>&nbsp;中每个键最多只会出现一次。<code>s</code>&nbsp;中不会有嵌套的括号。</p>\n\n<p>请你返回替换 <strong>所有</strong>&nbsp;括号对后的结果字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"(name)is(age)yearsold\", knowledge = [[\"name\",\"bob\"],[\"age\",\"two\"]]\n<b>输出：</b>\"bobistwoyearsold\"\n<strong>解释：</strong>\n键 \"name\" 对应的值为 \"bob\" ，所以将 \"(name)\" 替换为 \"bob\" 。\n键 \"age\" 对应的值为 \"two\" ，所以将 \"(age)\" 替换为 \"two\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"hi(name)\", knowledge = [[\"a\",\"b\"]]\n<b>输出：</b>\"hi?\"\n<b>解释：</b>由于不知道键 \"name\" 对应的值，所以用 \"?\" 替换 \"(name)\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"(a)(a)(a)aaa\", knowledge = [[\"a\",\"yes\"]]\n<b>输出：</b>\"yesyesyesaaa\"\n<b>解释：</b>相同的键在 s 中可能会出现多次。\n键 \"a\" 对应的值为 \"yes\" ，所以将所有的 \"(a)\" 替换为 \"yes\" 。\n注意，不在括号里的 \"a\" 不需要被替换。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= knowledge.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>knowledge[i].length == 2</code></li>\n\t<li><code>1 &lt;= key<sub>i</sub>.length, value<sub>i</sub>.length &lt;= 10</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母和圆括号&nbsp;<code>'('</code>&nbsp;和&nbsp;<code>')'</code>&nbsp;。</li>\n\t<li><code>s</code>&nbsp;中每一个左圆括号&nbsp;<code>'('</code>&nbsp;都有对应的右圆括号&nbsp;<code>')'</code>&nbsp;。</li>\n\t<li><code>s</code>&nbsp;中每对括号内的键都不会为空。</li>\n\t<li><code>s</code>&nbsp;中不会有嵌套括号对。</li>\n\t<li><code>key<sub>i</sub></code>&nbsp;和&nbsp;<code>value<sub>i</sub></code>&nbsp;只包含小写英文字母。</li>\n\t<li><code>knowledge</code>&nbsp;中的&nbsp;<code>key<sub>i</sub></code>&nbsp;不会重复。</li>\n</ul>\n", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class Solution {\npublic:\n    string evaluate(string s, vector<vector<string>>& knowledge) {\n        \n    }\n};"}, {"value": "java", "text": "Java", "defaultCode": "class Solution {\n    public String evaluate(String s, List<List<String>> knowledge) {\n        \n    }\n}"}, {"value": "python", "text": "Python", "defaultCode": "class Solution(object):\n    def evaluate(self, s, knowledge):\n        \"\"\"\n        :type s: str\n        :type knowledge: List[List[str]]\n        :rtype: str\n        \"\"\"\n        "}, {"value": "python3", "text": "Python3", "defaultCode": "class Solution:\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\n        "}, {"value": "c", "text": "C", "defaultCode": "char* evaluate(char* s, char*** knowledge, int knowledgeSize, int* knowledgeColSize) {\n    \n}"}, {"value": "csharp", "text": "C#", "defaultCode": "public class Solution {\n    public string Evaluate(string s, IList<IList<string>> knowledge) {\n        \n    }\n}"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * @param {string} s\n * @param {string[][]} knowledge\n * @return {string}\n */\nvar evaluate = function(s, knowledge) {\n    \n};"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "function evaluate(s: string, knowledge: string[][]): string {\n    \n};"}, {"value": "php", "text": "PHP", "defaultCode": "class Solution {\n\n    /**\n     * @param String $s\n     * @param String[][] $knowledge\n     * @return String\n     */\n    function evaluate($s, $knowledge) {\n        \n    }\n}"}, {"value": "swift", "text": "Swift", "defaultCode": "class Solution {\n    func evaluate(_ s: String, _ knowledge: [[String]]) -> String {\n        \n    }\n}"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class Solution {\n    fun evaluate(s: String, knowledge: List<List<String>>): String {\n        \n    }\n}"}, {"value": "dart", "text": "Dart", "defaultCode": "class Solution {\n  String evaluate(String s, List<List<String>> knowledge) {\n    \n  }\n}"}, {"value": "golang", "text": "Go", "defaultCode": "func evaluate(s string, knowledge [][]string) string {\n    \n}"}, {"value": "ruby", "text": "Ruby", "defaultCode": "# @param {String} s\n# @param {String[][]} knowledge\n# @return {String}\ndef evaluate(s, knowledge)\n    \nend"}, {"value": "scala", "text": "Scala", "defaultCode": "object Solution {\n    def evaluate(s: String, knowledge: List[List[String]]): String = {\n        \n    }\n}"}, {"value": "rust", "text": "Rust", "defaultCode": "impl Solution {\n    pub fn evaluate(s: String, knowledge: Vec<Vec<String>>) -> String {\n        \n    }\n}"}, {"value": "racket", "text": "Racket", "defaultCode": "(define/contract (evaluate s knowledge)\n  (-> string? (listof (listof string?)) string?)\n  )"}, {"value": "erlang", "text": "Erlang", "defaultCode": "-spec evaluate(S :: unicode:unicode_binary(), Knowledge :: [[unicode:unicode_binary()]]) -> unicode:unicode_binary().\nevaluate(S, Knowledge) ->\n  ."}, {"value": "elixir", "text": "Elixir", "defaultCode": "defmodule Solution do\n  @spec evaluate(s :: String.t, knowledge :: [[String.t]]) :: String.t\n  def evaluate(s, knowledge) do\n    \n  end\nend"}, {"value": "cangjie", "text": "Cangjie", "defaultCode": "class Solution {\n    func evaluate(s: String, knowledge: ArrayList<ArrayList<String>>): String {\n\n    }\n}"}]}