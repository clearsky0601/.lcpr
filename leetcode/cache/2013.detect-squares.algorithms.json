{"id": 2013, "fid": "2013", "name": "检测正方形", "slug": "detect-squares", "link": "https://leetcode.cn/problems/detect-squares/description/", "percent": 0, "level": "Medium", "category": "algorithms", "en_name": "Detect Squares", "cn_name": "检测正方形", "desc": "<p>给你一个在 X-Y 平面上的点构成的数据流。设计一个满足下述要求的算法：</p>\n\n<ul>\n\t<li><strong>添加</strong> 一个在数据流中的新点到某个数据结构中<strong>。</strong>可以添加 <strong>重复</strong> 的点，并会视作不同的点进行处理。</li>\n\t<li>给你一个查询点，请你从数据结构中选出三个点，使这三个点和查询点一同构成一个 <strong>面积为正</strong> 的 <strong>轴对齐正方形</strong> ，<strong>统计</strong> 满足该要求的方案数目<strong>。</strong></li>\n</ul>\n\n<p><strong>轴对齐正方形</strong> 是一个正方形，除四条边长度相同外，还满足每条边都与 x-轴 或 y-轴 平行或垂直。</p>\n\n<p>实现 <code>DetectSquares</code> 类：</p>\n\n<ul>\n\t<li><code>DetectSquares()</code> 使用空数据结构初始化对象</li>\n\t<li><code>void add(int[] point)</code> 向数据结构添加一个新的点 <code>point = [x, y]</code></li>\n\t<li><code>int count(int[] point)</code> 统计按上述方式与点 <code>point = [x, y]</code> 共同构造 <strong>轴对齐正方形</strong> 的方案数。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/01/image.png\" style=\"width: 869px; height: 504px;\" />\n<pre>\n<strong>输入：</strong>\n[\"DetectSquares\", \"add\", \"add\", \"add\", \"count\", \"count\", \"add\", \"count\"]\n[[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]]\n<strong>输出：</strong>\n[null, null, null, null, 1, 0, null, 2]\n\n<strong>解释：</strong>\nDetectSquares detectSquares = new DetectSquares();\ndetectSquares.add([3, 10]);\ndetectSquares.add([11, 2]);\ndetectSquares.add([3, 2]);\ndetectSquares.count([11, 10]); // 返回 1 。你可以选择：\n                               //   - 第一个，第二个，和第三个点\ndetectSquares.count([14, 8]);  // 返回 0 。查询点无法与数据结构中的这些点构成正方形。\ndetectSquares.add([11, 2]);    // 允许添加重复的点。\ndetectSquares.count([11, 10]); // 返回 2 。你可以选择：\n                               //   - 第一个，第二个，和第三个点\n                               //   - 第一个，第三个，和第四个点\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>point.length == 2</code></li>\n\t<li><code>0 &lt;= x, y &lt;= 1000</code></li>\n\t<li>调用&nbsp;<code>add</code> 和 <code>count</code> 的 <strong>总次数</strong> 最多为 <code>5000</code></li>\n</ul>\n", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class DetectSquares {\npublic:\n    DetectSquares() {\n        \n    }\n    \n    void add(vector<int> point) {\n        \n    }\n    \n    int count(vector<int> point) {\n        \n    }\n};\n\n/**\n * Your DetectSquares object will be instantiated and called as such:\n * DetectSquares* obj = new DetectSquares();\n * obj->add(point);\n * int param_2 = obj->count(point);\n */"}, {"value": "java", "text": "Java", "defaultCode": "class DetectSquares {\n\n    public DetectSquares() {\n        \n    }\n    \n    public void add(int[] point) {\n        \n    }\n    \n    public int count(int[] point) {\n        \n    }\n}\n\n/**\n * Your DetectSquares object will be instantiated and called as such:\n * DetectSquares obj = new DetectSquares();\n * obj.add(point);\n * int param_2 = obj.count(point);\n */"}, {"value": "python", "text": "Python", "defaultCode": "class DetectSquares(object):\n\n    def __init__(self):\n        \n\n    def add(self, point):\n        \"\"\"\n        :type point: List[int]\n        :rtype: None\n        \"\"\"\n        \n\n    def count(self, point):\n        \"\"\"\n        :type point: List[int]\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your DetectSquares object will be instantiated and called as such:\n# obj = DetectSquares()\n# obj.add(point)\n# param_2 = obj.count(point)"}, {"value": "python3", "text": "Python3", "defaultCode": "class DetectSquares:\n\n    def __init__(self):\n        \n\n    def add(self, point: List[int]) -> None:\n        \n\n    def count(self, point: List[int]) -> int:\n        \n\n\n# Your DetectSquares object will be instantiated and called as such:\n# obj = DetectSquares()\n# obj.add(point)\n# param_2 = obj.count(point)"}, {"value": "c", "text": "C", "defaultCode": "\n\n\ntypedef struct {\n    \n} DetectSquares;\n\n\nDetectSquares* detectSquaresCreate() {\n    \n}\n\nvoid detectSquaresAdd(DetectSquares* obj, int* point, int pointSize) {\n    \n}\n\nint detectSquaresCount(DetectSquares* obj, int* point, int pointSize) {\n    \n}\n\nvoid detectSquaresFree(DetectSquares* obj) {\n    \n}\n\n/**\n * Your DetectSquares struct will be instantiated and called as such:\n * DetectSquares* obj = detectSquaresCreate();\n * detectSquaresAdd(obj, point, pointSize);\n \n * int param_2 = detectSquaresCount(obj, point, pointSize);\n \n * detectSquaresFree(obj);\n*/"}, {"value": "csharp", "text": "C#", "defaultCode": "public class DetectSquares {\n\n    public DetectSquares() {\n        \n    }\n    \n    public void Add(int[] point) {\n        \n    }\n    \n    public int Count(int[] point) {\n        \n    }\n}\n\n/**\n * Your DetectSquares object will be instantiated and called as such:\n * DetectSquares obj = new DetectSquares();\n * obj.Add(point);\n * int param_2 = obj.Count(point);\n */"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "\nvar DetectSquares = function() {\n    \n};\n\n/** \n * @param {number[]} point\n * @return {void}\n */\nDetectSquares.prototype.add = function(point) {\n    \n};\n\n/** \n * @param {number[]} point\n * @return {number}\n */\nDetectSquares.prototype.count = function(point) {\n    \n};\n\n/** \n * Your DetectSquares object will be instantiated and called as such:\n * var obj = new DetectSquares()\n * obj.add(point)\n * var param_2 = obj.count(point)\n */"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "class DetectSquares {\n    constructor() {\n        \n    }\n\n    add(point: number[]): void {\n        \n    }\n\n    count(point: number[]): number {\n        \n    }\n}\n\n/**\n * Your DetectSquares object will be instantiated and called as such:\n * var obj = new DetectSquares()\n * obj.add(point)\n * var param_2 = obj.count(point)\n */"}, {"value": "php", "text": "PHP", "defaultCode": "class DetectSquares {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer[] $point\n     * @return NULL\n     */\n    function add($point) {\n        \n    }\n  \n    /**\n     * @param Integer[] $point\n     * @return Integer\n     */\n    function count($point) {\n        \n    }\n}\n\n/**\n * Your DetectSquares object will be instantiated and called as such:\n * $obj = DetectSquares();\n * $obj->add($point);\n * $ret_2 = $obj->count($point);\n */"}, {"value": "swift", "text": "Swift", "defaultCode": "\nclass DetectSquares {\n\n    init() {\n        \n    }\n    \n    func add(_ point: [Int]) {\n        \n    }\n    \n    func count(_ point: [Int]) -> Int {\n        \n    }\n}\n\n/**\n * Your DetectSquares object will be instantiated and called as such:\n * let obj = DetectSquares()\n * obj.add(point)\n * let ret_2: Int = obj.count(point)\n */"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class DetectSquares() {\n\n    fun add(point: IntArray) {\n        \n    }\n\n    fun count(point: IntArray): Int {\n        \n    }\n\n}\n\n/**\n * Your DetectSquares object will be instantiated and called as such:\n * var obj = DetectSquares()\n * obj.add(point)\n * var param_2 = obj.count(point)\n */"}, {"value": "dart", "text": "Dart", "defaultCode": "class DetectSquares {\n\n  DetectSquares() {\n    \n  }\n  \n  void add(List<int> point) {\n    \n  }\n  \n  int count(List<int> point) {\n    \n  }\n}\n\n/**\n * Your DetectSquares object will be instantiated and called as such:\n * DetectSquares obj = DetectSquares();\n * obj.add(point);\n * int param2 = obj.count(point);\n */"}, {"value": "golang", "text": "Go", "defaultCode": "type DetectSquares struct {\n    \n}\n\n\nfunc Constructor() DetectSquares {\n    \n}\n\n\nfunc (this *DetectSquares) Add(point []int)  {\n    \n}\n\n\nfunc (this *DetectSquares) Count(point []int) int {\n    \n}\n\n\n/**\n * Your DetectSquares object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Add(point);\n * param_2 := obj.Count(point);\n */"}, {"value": "ruby", "text": "Ruby", "defaultCode": "class DetectSquares\n    def initialize()\n        \n    end\n\n\n=begin\n    :type point: Integer[]\n    :rtype: Void\n=end\n    def add(point)\n        \n    end\n\n\n=begin\n    :type point: Integer[]\n    :rtype: Integer\n=end\n    def count(point)\n        \n    end\n\n\nend\n\n# Your DetectSquares object will be instantiated and called as such:\n# obj = DetectSquares.new()\n# obj.add(point)\n# param_2 = obj.count(point)"}, {"value": "scala", "text": "Scala", "defaultCode": "class DetectSquares() {\n\n    def add(point: Array[Int]): Unit = {\n        \n    }\n\n    def count(point: Array[Int]): Int = {\n        \n    }\n\n}\n\n/**\n * Your DetectSquares object will be instantiated and called as such:\n * val obj = new DetectSquares()\n * obj.add(point)\n * val param_2 = obj.count(point)\n */"}, {"value": "rust", "text": "Rust", "defaultCode": "struct DetectSquares {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl DetectSquares {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn add(&self, point: Vec<i32>) {\n        \n    }\n    \n    fn count(&self, point: Vec<i32>) -> i32 {\n        \n    }\n}\n\n/**\n * Your DetectSquares object will be instantiated and called as such:\n * let obj = DetectSquares::new();\n * obj.add(point);\n * let ret_2: i32 = obj.count(point);\n */"}, {"value": "racket", "text": "Racket", "defaultCode": "(define detect-squares%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; add : (listof exact-integer?) -> void?\n    (define/public (add point)\n      )\n    ; count : (listof exact-integer?) -> exact-integer?\n    (define/public (count point)\n      )))\n\n;; Your detect-squares% object will be instantiated and called as such:\n;; (define obj (new detect-squares%))\n;; (send obj add point)\n;; (define param_2 (send obj count point))"}, {"value": "erlang", "text": "Erlang", "defaultCode": "-spec detect_squares_init_() -> any().\ndetect_squares_init_() ->\n  .\n\n-spec detect_squares_add(Point :: [integer()]) -> any().\ndetect_squares_add(Point) ->\n  .\n\n-spec detect_squares_count(Point :: [integer()]) -> integer().\ndetect_squares_count(Point) ->\n  .\n\n\n%% Your functions will be called as such:\n%% detect_squares_init_(),\n%% detect_squares_add(Point),\n%% Param_2 = detect_squares_count(Point),\n\n%% detect_squares_init_ will be called before every test case, in which you can do some necessary initializations."}, {"value": "elixir", "text": "Elixir", "defaultCode": "defmodule DetectSquares do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec add(point :: [integer]) :: any\n  def add(point) do\n    \n  end\n\n  @spec count(point :: [integer]) :: integer\n  def count(point) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# DetectSquares.init_()\n# DetectSquares.add(point)\n# param_2 = DetectSquares.count(point)\n\n# DetectSquares.init_ will be called before every test case, in which you can do some necessary initializations."}, {"value": "cangjie", "text": "Cangjie", "defaultCode": "class DetectSquares {\n    init() {\n\n    }\n    \n    func add(point: Array<Int64>): Unit {\n\n    }\n    \n    func count(point: Array<Int64>): Int64 {\n\n    }\n}\n\n/**\n * Your DetectSquares object will be instantiated and called as such:\n * let obj: DetectSquares = DetectSquares()\n * obj.add(point)\n * let param_2 = obj.count(point)\n */"}]}