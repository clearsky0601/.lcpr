{"id": "LCP 76", "fid": "LCP 76", "name": "魔法棋盘", "slug": "1ybDKD", "link": "https://leetcode.cn/problems/1ybDKD/description/", "percent": 0, "level": "Hard", "category": "algorithms", "en_name": "魔法棋盘", "cn_name": "魔法棋盘", "desc": "在大小为 `n * m` 的棋盘中，有两种不同的棋子：黑色，红色。当两颗颜色不同的棋子同时满足以下两种情况时，将会产生魔法共鸣：\n- 两颗异色棋子在同一行或者同一列\n- 两颗异色棋子之间恰好只有一颗棋子\n    > 注：异色棋子之间可以有空位\n\n由于棋盘上被施加了魔法禁制，棋盘上的部分格子变成问号。`chessboard[i][j]` 表示棋盘第 `i` 行 `j` 列的状态：\n- 若为 `.` ，表示当前格子确定为空\n- 若为 `B` ，表示当前格子确定为 黑棋\n- 若为 `R` ，表示当前格子确定为 红棋\n- 若为 `?` ，表示当前格子待定\n\n现在，探险家小扣的任务是确定所有问号位置的状态（留空/放黑棋/放红棋），使最终的棋盘上，任意两颗棋子间都 **无法** 产生共鸣。请返回可以满足上述条件的放置方案数量。\n\n**示例1：**\n> 输入：`n = 3, m = 3, chessboard = [\"..R\",\"..B\",\"?R?\"]`\n>\n> 输出：`5`\n>\n> 解释：给定的棋盘如图：\n>![image.png](https://pic.leetcode.cn/1681714583-unbRox-image.png){:height=150px}\n> 所有符合题意的最终局面如图：\n>![image.png](https://pic.leetcode.cn/1681714596-beaOHK-image.png){:height=150px}\n\n**示例2：**\n> 输入：`n = 3, m = 3, chessboard = [\"?R?\",\"B?B\",\"?R?\"]`\n>\n> 输出：`105`\n\n**提示：**\n- `n == chessboard.length`\n- `m == chessboard[i].length`\n- `1 <= n*m <= 30`\n- `chessboard` 中仅包含 `\".\"、\"B\"、\"R\"、\"?\"`", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class Solution {\npublic:\n    long long getSchemeCount(int n, int m, vector<string>& chessboard) {\n\n    }\n};"}, {"value": "java", "text": "Java", "defaultCode": "class Solution {\n    public long getSchemeCount(int n, int m, String[] chessboard) {\n\n    }\n}"}, {"value": "python", "text": "Python", "defaultCode": "class Solution(object):\n    def getSchemeCount(self, n, m, chessboard):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :type chessboard: List[str]\n        :rtype: int\n        \"\"\""}, {"value": "python3", "text": "Python3", "defaultCode": "class Solution:\n    def getSchemeCount(self, n: int, m: int, chessboard: List[str]) -> int:"}, {"value": "c", "text": "C", "defaultCode": "long long getSchemeCount(int n, int m, char** chessboard, int chessboardSize){\n\n}"}, {"value": "csharp", "text": "C#", "defaultCode": "public class Solution {\n    public long GetSchemeCount(int n, int m, string[] chessboard) {\n\n    }\n}"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * @param {number} n\n * @param {number} m\n * @param {string[]} chessboard\n * @return {number}\n */\nvar getSchemeCount = function(n, m, chessboard) {\n\n};"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "function getSchemeCount(n: number, m: number, chessboard: string[]): number {\n\n};"}, {"value": "php", "text": "PHP", "defaultCode": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer $m\n     * @param String[] $chessboard\n     * @return Integer\n     */\n    function getSchemeCount($n, $m, $chessboard) {\n\n    }\n}"}, {"value": "swift", "text": "Swift", "defaultCode": "class Solution {\n    func getSchemeCount(_ n: Int, _ m: Int, _ chessboard: [String]) -> Int {\n\n    }\n}"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class Solution {\n    fun getSchemeCount(n: Int, m: Int, chessboard: Array<String>): Long {\n\n    }\n}"}, {"value": "dart", "text": "Dart", "defaultCode": "class Solution {\n  int getSchemeCount(int n, int m, List<String> chessboard) {\n\n  }\n}"}, {"value": "golang", "text": "Go", "defaultCode": "func getSchemeCount(n int, m int, chessboard []string) int64 {\n\n}"}, {"value": "ruby", "text": "Ruby", "defaultCode": "# @param {Integer} n\n# @param {Integer} m\n# @param {String[]} chessboard\n# @return {Integer}\ndef get_scheme_count(n, m, chessboard)\n\nend"}, {"value": "scala", "text": "Scala", "defaultCode": "object Solution {\n    def getSchemeCount(n: Int, m: Int, chessboard: Array[String]): Long = {\n\n    }\n}"}, {"value": "rust", "text": "Rust", "defaultCode": "impl Solution {\n    pub fn get_scheme_count(n: i32, m: i32, chessboard: Vec<String>) -> i64 {\n\n    }\n}"}, {"value": "racket", "text": "Racket", "defaultCode": "(define/contract (get-scheme-count n m chessboard)\n  (-> exact-integer? exact-integer? (listof string?) exact-integer?)\n\n  )"}, {"value": "erlang", "text": "Erlang", "defaultCode": "-spec get_scheme_count(N :: integer(), M :: integer(), Chessboard :: [unicode:unicode_binary()]) -> integer().\nget_scheme_count(N, M, Chessboard) ->\n  ."}, {"value": "elixir", "text": "Elixir", "defaultCode": "defmodule Solution do\n  @spec get_scheme_count(n :: integer, m :: integer, chessboard :: [String.t]) :: integer\n  def get_scheme_count(n, m, chessboard) do\n\n  end\nend"}]}