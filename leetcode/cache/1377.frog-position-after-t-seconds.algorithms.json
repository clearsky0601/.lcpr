{"id": 1377, "fid": "1377", "name": "T 秒后青蛙的位置", "slug": "frog-position-after-t-seconds", "link": "https://leetcode.cn/problems/frog-position-after-t-seconds/description/", "percent": 0, "level": "Hard", "category": "algorithms", "en_name": "Frog Position After T Seconds", "cn_name": "T 秒后青蛙的位置", "desc": "<p>给你一棵由 <code>n</code> 个顶点组成的无向树，顶点编号从 <code>1</code> 到 <code>n</code>。青蛙从 <strong>顶点 1</strong> 开始起跳。规则如下：</p>\n\n<ul>\n\t<li>在一秒内，青蛙从它所在的当前顶点跳到另一个 <strong>未访问</strong> 过的顶点（如果它们直接相连）。</li>\n\t<li>青蛙无法跳回已经访问过的顶点。</li>\n\t<li>如果青蛙可以跳到多个不同顶点，那么它跳到其中任意一个顶点上的机率都相同。</li>\n\t<li>如果青蛙不能跳到任何未访问过的顶点上，那么它每次跳跃都会停留在原地。</li>\n</ul>\n\n<p>无向树的边用数组 <code>edges</code> 描述，其中 <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 意味着存在一条直接连通 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 两个顶点的边。</p>\n\n<p>返回青蛙在 <em><code>t</code></em> 秒后位于目标顶点 <em><code>target</code> </em>上的概率。与实际答案相差不超过 <code>10<sup>-5</sup></code> 的结果将被视为正确答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/12/21/frog1.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4\n<strong>输出：</strong>0.16666666666666666 \n<strong>解释：</strong>上图显示了青蛙的跳跃路径。青蛙从顶点 1 起跳，第 <strong>1 秒</strong> 有 1/3 的概率跳到顶点 2 ，然后第 <strong>2 秒</strong> 有 1/2 的概率跳到顶点 4，因此青蛙在 2 秒后位于顶点 4 的概率是 1/3 * 1/2 = 1/6 = 0.16666666666666666 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/12/21/frog2.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7\n<strong>输出：</strong>0.3333333333333333\n<strong>解释：</strong>上图显示了青蛙的跳跃路径。青蛙从顶点 1 起跳，有 1/3 = 0.3333333333333333 的概率能够 <strong>1 秒</strong> 后跳到顶点 7 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub>&nbsp;&lt;= n</code></li>\n\t<li><code>1 &lt;= t &lt;= 50</code></li>\n\t<li><code>1 &lt;= target &lt;= n</code></li>\n</ul>\n", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class Solution {\npublic:\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\n        \n    }\n};"}, {"value": "java", "text": "Java", "defaultCode": "class Solution {\n    public double frogPosition(int n, int[][] edges, int t, int target) {\n        \n    }\n}"}, {"value": "python", "text": "Python", "defaultCode": "class Solution(object):\n    def frogPosition(self, n, edges, t, target):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type t: int\n        :type target: int\n        :rtype: float\n        \"\"\"\n        "}, {"value": "python3", "text": "Python3", "defaultCode": "class Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        "}, {"value": "c", "text": "C", "defaultCode": "double frogPosition(int n, int** edges, int edgesSize, int* edgesColSize, int t, int target) {\n    \n}"}, {"value": "csharp", "text": "C#", "defaultCode": "public class Solution {\n    public double FrogPosition(int n, int[][] edges, int t, int target) {\n        \n    }\n}"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number} t\n * @param {number} target\n * @return {number}\n */\nvar frogPosition = function(n, edges, t, target) {\n    \n};"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "function frogPosition(n: number, edges: number[][], t: number, target: number): number {\n    \n};"}, {"value": "php", "text": "PHP", "defaultCode": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $edges\n     * @param Integer $t\n     * @param Integer $target\n     * @return Float\n     */\n    function frogPosition($n, $edges, $t, $target) {\n        \n    }\n}"}, {"value": "swift", "text": "Swift", "defaultCode": "class Solution {\n    func frogPosition(_ n: Int, _ edges: [[Int]], _ t: Int, _ target: Int) -> Double {\n        \n    }\n}"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class Solution {\n    fun frogPosition(n: Int, edges: Array<IntArray>, t: Int, target: Int): Double {\n        \n    }\n}"}, {"value": "dart", "text": "Dart", "defaultCode": "class Solution {\n  double frogPosition(int n, List<List<int>> edges, int t, int target) {\n    \n  }\n}"}, {"value": "golang", "text": "Go", "defaultCode": "func frogPosition(n int, edges [][]int, t int, target int) float64 {\n    \n}"}, {"value": "ruby", "text": "Ruby", "defaultCode": "# @param {Integer} n\n# @param {Integer[][]} edges\n# @param {Integer} t\n# @param {Integer} target\n# @return {Float}\ndef frog_position(n, edges, t, target)\n    \nend"}, {"value": "scala", "text": "Scala", "defaultCode": "object Solution {\n    def frogPosition(n: Int, edges: Array[Array[Int]], t: Int, target: Int): Double = {\n        \n    }\n}"}, {"value": "rust", "text": "Rust", "defaultCode": "impl Solution {\n    pub fn frog_position(n: i32, edges: Vec<Vec<i32>>, t: i32, target: i32) -> f64 {\n        \n    }\n}"}, {"value": "racket", "text": "Racket", "defaultCode": "(define/contract (frog-position n edges t target)\n  (-> exact-integer? (listof (listof exact-integer?)) exact-integer? exact-integer? flonum?)\n  )"}, {"value": "erlang", "text": "Erlang", "defaultCode": "-spec frog_position(N :: integer(), Edges :: [[integer()]], T :: integer(), Target :: integer()) -> float().\nfrog_position(N, Edges, T, Target) ->\n  ."}, {"value": "elixir", "text": "Elixir", "defaultCode": "defmodule Solution do\n  @spec frog_position(n :: integer, edges :: [[integer]], t :: integer, target :: integer) :: float\n  def frog_position(n, edges, t, target) do\n    \n  end\nend"}, {"value": "cangjie", "text": "Cangjie", "defaultCode": "class Solution {\n    func frogPosition(n: Int64, edges: Array<Array<Int64>>, t: Int64, target: Int64): Float64 {\n\n    }\n}"}]}