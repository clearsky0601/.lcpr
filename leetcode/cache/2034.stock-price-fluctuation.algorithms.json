{"id": 2034, "fid": "2034", "name": "股票价格波动", "slug": "stock-price-fluctuation", "link": "https://leetcode.cn/problems/stock-price-fluctuation/description/", "percent": 0, "level": "Medium", "category": "algorithms", "en_name": "Stock Price Fluctuation ", "cn_name": "股票价格波动", "desc": "<p>给你一支股票价格的数据流。数据流中每一条记录包含一个 <strong>时间戳</strong>&nbsp;和该时间点股票对应的 <strong>价格</strong>&nbsp;。</p>\n\n<p>不巧的是，由于股票市场内在的波动性，股票价格记录可能不是按时间顺序到来的。某些情况下，有的记录可能是错的。如果两个有相同时间戳的记录出现在数据流中，前一条记录视为错误记录，后出现的记录 <b>更正</b>&nbsp;前一条错误的记录。</p>\n\n<p>请你设计一个算法，实现：</p>\n\n<ul>\n\t<li><strong>更新 </strong>股票在某一时间戳的股票价格，如果有之前同一时间戳的价格，这一操作将&nbsp;<strong>更正</strong>&nbsp;之前的错误价格。</li>\n\t<li>找到当前记录里 <b>最新股票价格</b>&nbsp;。<strong>最新股票价格</strong>&nbsp;定义为时间戳最晚的股票价格。</li>\n\t<li>找到当前记录里股票的 <strong>最高价格</strong>&nbsp;。</li>\n\t<li>找到当前记录里股票的 <strong>最低价格</strong>&nbsp;。</li>\n</ul>\n\n<p>请你实现&nbsp;<code>StockPrice</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>StockPrice()</code>&nbsp;初始化对象，当前无股票价格记录。</li>\n\t<li><code>void update(int timestamp, int price)</code>&nbsp;在时间点 <code>timestamp</code>&nbsp;更新股票价格为 <code>price</code>&nbsp;。</li>\n\t<li><code>int current()</code>&nbsp;返回股票 <strong>最新价格</strong>&nbsp;。</li>\n\t<li><code>int maximum()</code>&nbsp;返回股票 <strong>最高价格</strong>&nbsp;。</li>\n\t<li><code>int minimum()</code>&nbsp;返回股票 <strong>最低价格</strong>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>\n[\"StockPrice\", \"update\", \"update\", \"current\", \"maximum\", \"update\", \"maximum\", \"update\", \"minimum\"]\n[[], [1, 10], [2, 5], [], [], [1, 3], [], [4, 2], []]\n<strong>输出：</strong>\n[null, null, null, 5, 10, null, 5, null, 2]\n\n<strong>解释：</strong>\nStockPrice stockPrice = new StockPrice();\nstockPrice.update(1, 10); // 时间戳为 [1] ，对应的股票价格为 [10] 。\nstockPrice.update(2, 5);  // 时间戳为 [1,2] ，对应的股票价格为 [10,5] 。\nstockPrice.current();     // 返回 5 ，最新时间戳为 2 ，对应价格为 5 。\nstockPrice.maximum();     // 返回 10 ，最高价格的时间戳为 1 ，价格为 10 。\nstockPrice.update(1, 3);  // 之前时间戳为 1 的价格错误，价格更新为 3 。\n                          // 时间戳为 [1,2] ，对应股票价格为 [3,5] 。\nstockPrice.maximum();     // 返回 5 ，更正后最高价格为 5 。\nstockPrice.update(4, 2);  // 时间戳为 [1,2,4] ，对应价格为 [3,5,2] 。\nstockPrice.minimum();     // 返回 2 ，最低价格时间戳为 4 ，价格为 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= timestamp, price &lt;= 10<sup>9</sup></code></li>\n\t<li><code>update</code>，<code>current</code>，<code>maximum</code>&nbsp;和&nbsp;<code>minimum</code>&nbsp;<strong>总</strong> 调用次数不超过&nbsp;<code>10<sup>5</sup></code>&nbsp;。</li>\n\t<li><code>current</code>，<code>maximum</code>&nbsp;和&nbsp;<code>minimum</code>&nbsp;被调用时，<code>update</code>&nbsp;操作 <strong>至少</strong>&nbsp;已经被调用过 <strong>一次</strong>&nbsp;。</li>\n</ul>\n", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class StockPrice {\npublic:\n    StockPrice() {\n        \n    }\n    \n    void update(int timestamp, int price) {\n        \n    }\n    \n    int current() {\n        \n    }\n    \n    int maximum() {\n        \n    }\n    \n    int minimum() {\n        \n    }\n};\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * StockPrice* obj = new StockPrice();\n * obj->update(timestamp,price);\n * int param_2 = obj->current();\n * int param_3 = obj->maximum();\n * int param_4 = obj->minimum();\n */"}, {"value": "java", "text": "Java", "defaultCode": "class StockPrice {\n\n    public StockPrice() {\n        \n    }\n    \n    public void update(int timestamp, int price) {\n        \n    }\n    \n    public int current() {\n        \n    }\n    \n    public int maximum() {\n        \n    }\n    \n    public int minimum() {\n        \n    }\n}\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * StockPrice obj = new StockPrice();\n * obj.update(timestamp,price);\n * int param_2 = obj.current();\n * int param_3 = obj.maximum();\n * int param_4 = obj.minimum();\n */"}, {"value": "python", "text": "Python", "defaultCode": "class StockPrice(object):\n\n    def __init__(self):\n        \n\n    def update(self, timestamp, price):\n        \"\"\"\n        :type timestamp: int\n        :type price: int\n        :rtype: None\n        \"\"\"\n        \n\n    def current(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def maximum(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def minimum(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your StockPrice object will be instantiated and called as such:\n# obj = StockPrice()\n# obj.update(timestamp,price)\n# param_2 = obj.current()\n# param_3 = obj.maximum()\n# param_4 = obj.minimum()"}, {"value": "python3", "text": "Python3", "defaultCode": "class StockPrice:\n\n    def __init__(self):\n        \n\n    def update(self, timestamp: int, price: int) -> None:\n        \n\n    def current(self) -> int:\n        \n\n    def maximum(self) -> int:\n        \n\n    def minimum(self) -> int:\n        \n\n\n# Your StockPrice object will be instantiated and called as such:\n# obj = StockPrice()\n# obj.update(timestamp,price)\n# param_2 = obj.current()\n# param_3 = obj.maximum()\n# param_4 = obj.minimum()"}, {"value": "c", "text": "C", "defaultCode": "\n\n\ntypedef struct {\n    \n} StockPrice;\n\n\nStockPrice* stockPriceCreate() {\n    \n}\n\nvoid stockPriceUpdate(StockPrice* obj, int timestamp, int price) {\n    \n}\n\nint stockPriceCurrent(StockPrice* obj) {\n    \n}\n\nint stockPriceMaximum(StockPrice* obj) {\n    \n}\n\nint stockPriceMinimum(StockPrice* obj) {\n    \n}\n\nvoid stockPriceFree(StockPrice* obj) {\n    \n}\n\n/**\n * Your StockPrice struct will be instantiated and called as such:\n * StockPrice* obj = stockPriceCreate();\n * stockPriceUpdate(obj, timestamp, price);\n \n * int param_2 = stockPriceCurrent(obj);\n \n * int param_3 = stockPriceMaximum(obj);\n \n * int param_4 = stockPriceMinimum(obj);\n \n * stockPriceFree(obj);\n*/"}, {"value": "csharp", "text": "C#", "defaultCode": "public class StockPrice {\n\n    public StockPrice() {\n        \n    }\n    \n    public void Update(int timestamp, int price) {\n        \n    }\n    \n    public int Current() {\n        \n    }\n    \n    public int Maximum() {\n        \n    }\n    \n    public int Minimum() {\n        \n    }\n}\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * StockPrice obj = new StockPrice();\n * obj.Update(timestamp,price);\n * int param_2 = obj.Current();\n * int param_3 = obj.Maximum();\n * int param_4 = obj.Minimum();\n */"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "\nvar StockPrice = function() {\n    \n};\n\n/** \n * @param {number} timestamp \n * @param {number} price\n * @return {void}\n */\nStockPrice.prototype.update = function(timestamp, price) {\n    \n};\n\n/**\n * @return {number}\n */\nStockPrice.prototype.current = function() {\n    \n};\n\n/**\n * @return {number}\n */\nStockPrice.prototype.maximum = function() {\n    \n};\n\n/**\n * @return {number}\n */\nStockPrice.prototype.minimum = function() {\n    \n};\n\n/** \n * Your StockPrice object will be instantiated and called as such:\n * var obj = new StockPrice()\n * obj.update(timestamp,price)\n * var param_2 = obj.current()\n * var param_3 = obj.maximum()\n * var param_4 = obj.minimum()\n */"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "class StockPrice {\n    constructor() {\n        \n    }\n\n    update(timestamp: number, price: number): void {\n        \n    }\n\n    current(): number {\n        \n    }\n\n    maximum(): number {\n        \n    }\n\n    minimum(): number {\n        \n    }\n}\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * var obj = new StockPrice()\n * obj.update(timestamp,price)\n * var param_2 = obj.current()\n * var param_3 = obj.maximum()\n * var param_4 = obj.minimum()\n */"}, {"value": "php", "text": "PHP", "defaultCode": "class StockPrice {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $timestamp\n     * @param Integer $price\n     * @return NULL\n     */\n    function update($timestamp, $price) {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function current() {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function maximum() {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function minimum() {\n        \n    }\n}\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * $obj = StockPrice();\n * $obj->update($timestamp, $price);\n * $ret_2 = $obj->current();\n * $ret_3 = $obj->maximum();\n * $ret_4 = $obj->minimum();\n */"}, {"value": "swift", "text": "Swift", "defaultCode": "\nclass StockPrice {\n\n    init() {\n        \n    }\n    \n    func update(_ timestamp: Int, _ price: Int) {\n        \n    }\n    \n    func current() -> Int {\n        \n    }\n    \n    func maximum() -> Int {\n        \n    }\n    \n    func minimum() -> Int {\n        \n    }\n}\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * let obj = StockPrice()\n * obj.update(timestamp, price)\n * let ret_2: Int = obj.current()\n * let ret_3: Int = obj.maximum()\n * let ret_4: Int = obj.minimum()\n */"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class StockPrice() {\n\n    fun update(timestamp: Int, price: Int) {\n        \n    }\n\n    fun current(): Int {\n        \n    }\n\n    fun maximum(): Int {\n        \n    }\n\n    fun minimum(): Int {\n        \n    }\n\n}\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * var obj = StockPrice()\n * obj.update(timestamp,price)\n * var param_2 = obj.current()\n * var param_3 = obj.maximum()\n * var param_4 = obj.minimum()\n */"}, {"value": "dart", "text": "Dart", "defaultCode": "class StockPrice {\n\n  StockPrice() {\n    \n  }\n  \n  void update(int timestamp, int price) {\n    \n  }\n  \n  int current() {\n    \n  }\n  \n  int maximum() {\n    \n  }\n  \n  int minimum() {\n    \n  }\n}\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * StockPrice obj = StockPrice();\n * obj.update(timestamp,price);\n * int param2 = obj.current();\n * int param3 = obj.maximum();\n * int param4 = obj.minimum();\n */"}, {"value": "golang", "text": "Go", "defaultCode": "type StockPrice struct {\n    \n}\n\n\nfunc Constructor() StockPrice {\n    \n}\n\n\nfunc (this *StockPrice) Update(timestamp int, price int)  {\n    \n}\n\n\nfunc (this *StockPrice) Current() int {\n    \n}\n\n\nfunc (this *StockPrice) Maximum() int {\n    \n}\n\n\nfunc (this *StockPrice) Minimum() int {\n    \n}\n\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Update(timestamp,price);\n * param_2 := obj.Current();\n * param_3 := obj.Maximum();\n * param_4 := obj.Minimum();\n */"}, {"value": "ruby", "text": "Ruby", "defaultCode": "class StockPrice\n    def initialize()\n        \n    end\n\n\n=begin\n    :type timestamp: Integer\n    :type price: Integer\n    :rtype: Void\n=end\n    def update(timestamp, price)\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def current()\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def maximum()\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def minimum()\n        \n    end\n\n\nend\n\n# Your StockPrice object will be instantiated and called as such:\n# obj = StockPrice.new()\n# obj.update(timestamp, price)\n# param_2 = obj.current()\n# param_3 = obj.maximum()\n# param_4 = obj.minimum()"}, {"value": "scala", "text": "Scala", "defaultCode": "class StockPrice() {\n\n    def update(timestamp: Int, price: Int): Unit = {\n        \n    }\n\n    def current(): Int = {\n        \n    }\n\n    def maximum(): Int = {\n        \n    }\n\n    def minimum(): Int = {\n        \n    }\n\n}\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * val obj = new StockPrice()\n * obj.update(timestamp,price)\n * val param_2 = obj.current()\n * val param_3 = obj.maximum()\n * val param_4 = obj.minimum()\n */"}, {"value": "rust", "text": "Rust", "defaultCode": "struct StockPrice {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl StockPrice {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn update(&self, timestamp: i32, price: i32) {\n        \n    }\n    \n    fn current(&self) -> i32 {\n        \n    }\n    \n    fn maximum(&self) -> i32 {\n        \n    }\n    \n    fn minimum(&self) -> i32 {\n        \n    }\n}\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * let obj = StockPrice::new();\n * obj.update(timestamp, price);\n * let ret_2: i32 = obj.current();\n * let ret_3: i32 = obj.maximum();\n * let ret_4: i32 = obj.minimum();\n */"}, {"value": "racket", "text": "Racket", "defaultCode": "(define stock-price%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; update : exact-integer? exact-integer? -> void?\n    (define/public (update timestamp price)\n      )\n    ; current : -> exact-integer?\n    (define/public (current)\n      )\n    ; maximum : -> exact-integer?\n    (define/public (maximum)\n      )\n    ; minimum : -> exact-integer?\n    (define/public (minimum)\n      )))\n\n;; Your stock-price% object will be instantiated and called as such:\n;; (define obj (new stock-price%))\n;; (send obj update timestamp price)\n;; (define param_2 (send obj current))\n;; (define param_3 (send obj maximum))\n;; (define param_4 (send obj minimum))"}, {"value": "erlang", "text": "Erlang", "defaultCode": "-spec stock_price_init_() -> any().\nstock_price_init_() ->\n  .\n\n-spec stock_price_update(Timestamp :: integer(), Price :: integer()) -> any().\nstock_price_update(Timestamp, Price) ->\n  .\n\n-spec stock_price_current() -> integer().\nstock_price_current() ->\n  .\n\n-spec stock_price_maximum() -> integer().\nstock_price_maximum() ->\n  .\n\n-spec stock_price_minimum() -> integer().\nstock_price_minimum() ->\n  .\n\n\n%% Your functions will be called as such:\n%% stock_price_init_(),\n%% stock_price_update(Timestamp, Price),\n%% Param_2 = stock_price_current(),\n%% Param_3 = stock_price_maximum(),\n%% Param_4 = stock_price_minimum(),\n\n%% stock_price_init_ will be called before every test case, in which you can do some necessary initializations."}, {"value": "elixir", "text": "Elixir", "defaultCode": "defmodule StockPrice do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec update(timestamp :: integer, price :: integer) :: any\n  def update(timestamp, price) do\n    \n  end\n\n  @spec current() :: integer\n  def current() do\n    \n  end\n\n  @spec maximum() :: integer\n  def maximum() do\n    \n  end\n\n  @spec minimum() :: integer\n  def minimum() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# StockPrice.init_()\n# StockPrice.update(timestamp, price)\n# param_2 = StockPrice.current()\n# param_3 = StockPrice.maximum()\n# param_4 = StockPrice.minimum()\n\n# StockPrice.init_ will be called before every test case, in which you can do some necessary initializations."}, {"value": "cangjie", "text": "Cangjie", "defaultCode": "class StockPrice {\n    init() {\n\n    }\n    \n    func update(timestamp: Int64, price: Int64): Unit {\n\n    }\n    \n    func current(): Int64 {\n\n    }\n    \n    func maximum(): Int64 {\n\n    }\n    \n    func minimum(): Int64 {\n\n    }\n}\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * let obj: StockPrice = StockPrice()\n * obj.update(timestamp,price)\n * let param_2 = obj.current()\n * let param_3 = obj.maximum()\n * let param_4 = obj.minimum()\n */"}]}