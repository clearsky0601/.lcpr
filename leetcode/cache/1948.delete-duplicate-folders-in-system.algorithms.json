{"id": 1948, "fid": "1948", "name": "删除系统中的重复文件夹", "slug": "delete-duplicate-folders-in-system", "link": "https://leetcode.cn/problems/delete-duplicate-folders-in-system/description/", "percent": 0, "level": "Hard", "category": "algorithms", "en_name": "Delete Duplicate Folders in System", "cn_name": "删除系统中的重复文件夹", "desc": "<p>由于一个漏洞，文件系统中存在许多重复文件夹。给你一个二维数组 <code>paths</code>，其中 <code>paths[i]</code> 是一个表示文件系统中第 <code>i</code> 个文件夹的绝对路径的数组。</p>\n\n<ul>\n\t<li>例如，<code>[\"one\", \"two\", \"three\"]</code> 表示路径 <code>\"/one/two/three\"</code> 。</li>\n</ul>\n\n<p>如果两个文件夹（不需要在同一层级）包含 <strong>非空且</strong><b>相同的&nbsp;</b>子文件夹&nbsp;<strong>集合</strong> 并具有相同的子文件夹结构，则认为这两个文件夹是相同文件夹。相同文件夹的根层级 <strong>不</strong> 需要相同。如果存在两个（或两个以上）<strong>相同</strong> 文件夹，则需要将这些文件夹和所有它们的子文件夹 <strong>标记</strong> 为待删除。</p>\n\n<ul>\n\t<li>例如，下面文件结构中的文件夹 <code>\"/a\"</code> 和 <code>\"/b\"</code> 相同。它们（以及它们的子文件夹）应该被 <strong>全部</strong> 标记为待删除：\n\n\t<ul>\n\t\t<li><code>/a</code></li>\n\t\t<li><code>/a/x</code></li>\n\t\t<li><code>/a/x/y</code></li>\n\t\t<li><code>/a/z</code></li>\n\t\t<li><code>/b</code></li>\n\t\t<li><code>/b/x</code></li>\n\t\t<li><code>/b/x/y</code></li>\n\t\t<li><code>/b/z</code></li>\n\t</ul>\n\t</li>\n\t<li>然而，如果文件结构中还包含路径 <code>\"/b/w\"</code> ，那么文件夹 <code>\"/a\"</code> 和 <code>\"/b\"</code> 就不相同。注意，即便添加了新的文件夹 <code>\"/b/w\"</code> ，仍然认为 <code>\"/a/x\"</code> 和 <code>\"/b/x\"</code> 相同。</li>\n</ul>\n\n<p>一旦所有的相同文件夹和它们的子文件夹都被标记为待删除，文件系统将会 <strong>删除</strong> 所有上述文件夹。文件系统只会执行一次删除操作。执行完这一次删除操作后，不会删除新出现的相同文件夹。</p>\n\n<p>返回二维数组<em> </em><code>ans</code> ，该数组包含删除所有标记文件夹之后剩余文件夹的路径。路径可以按 <strong>任意顺序</strong> 返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder1.jpg\" style=\"width: 200px; height: 218px;\" />\n<pre>\n<strong>输入：</strong>paths = [[\"a\"],[\"c\"],[\"d\"],[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"a\"]]\n<strong>输出：</strong>[[\"d\"],[\"d\",\"a\"]]\n<strong>解释：</strong>文件结构如上所示。\n文件夹 \"/a\" 和 \"/c\"（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 \"b\" 的空文件夹。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder2.jpg\" style=\"width: 200px; height: 355px;\" />\n<pre>\n<strong>输入：</strong>paths = [[\"a\"],[\"c\"],[\"a\",\"b\"],[\"c\",\"b\"],[\"a\",\"b\",\"x\"],[\"a\",\"b\",\"x\",\"y\"],[\"w\"],[\"w\",\"y\"]]\n<strong>输出：</strong>[[\"c\"],[\"c\",\"b\"],[\"a\"],[\"a\",\"b\"]]\n<strong>解释：</strong>文件结构如上所示。\n文件夹 \"/a/b/x\" 和 \"/w\"（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 \"y\" 的空文件夹。\n注意，文件夹 \"/a\" 和 \"/c\" 在删除后变为相同文件夹，但这两个文件夹不会被删除，因为删除只会进行一次，且它们没有在删除前被标记。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder3.jpg\" style=\"width: 200px; height: 201px;\" />\n<pre>\n<strong>输入：</strong>paths = [[\"a\",\"b\"],[\"c\",\"d\"],[\"c\"],[\"a\"]]\n<strong>输出：</strong>[[\"c\"],[\"c\",\"d\"],[\"a\"],[\"a\",\"b\"]]\n<strong>解释：</strong>文件系统中所有文件夹互不相同。\n注意，返回的数组可以按不同顺序返回文件夹路径，因为题目对顺序没有要求。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder4_.jpg\" style=\"width: 300px; height: 290px;\" />\n<pre>\n<strong>输入：</strong>paths = [[\"a\"],[\"a\",\"x\"],[\"a\",\"x\",\"y\"],[\"a\",\"z\"],[\"b\"],[\"b\",\"x\"],[\"b\",\"x\",\"y\"],[\"b\",\"z\"]]\n<strong>输出：</strong>[]\n<strong>解释：</strong>文件结构如上所示。\n文件夹 \"/a/x\" 和 \"/b/x\"（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 \"y\" 的空文件夹。\n文件夹 \"/a\" 和 \"/b\"（以及它们的子文件夹）都会被标记为待删除，因为它们都包含一个名为 \"z\" 的空文件夹以及上面提到的文件夹 \"x\" 。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder5_.jpg\" style=\"width: 300px; height: 282px;\" />\n<pre>\n<strong>输入：</strong>paths = [[\"a\"],[\"a\",\"x\"],[\"a\",\"x\",\"y\"],[\"a\",\"z\"],[\"b\"],[\"b\",\"x\"],[\"b\",\"x\",\"y\"],[\"b\",\"z\"],[\"b\",\"w\"]]\n<strong>输出：</strong>[[\"b\"],[\"b\",\"w\"],[\"b\",\"z\"],[\"a\"],[\"a\",\"z\"]]\n<strong>解释：</strong>本例与上例的结构基本相同，除了新增 \"/b/w\" 文件夹。\n文件夹 \"/a/x\" 和 \"/b/x\" 仍然会被标记，但 \"/a\" 和 \"/b\" 不再被标记，因为 \"/b\" 中有名为 \"w\" 的空文件夹而 \"/a\" 没有。\n注意，\"/a/z\" 和 \"/b/z\" 不会被标记，因为相同子文件夹的集合必须是非空集合，但这两个文件夹都是空的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= paths.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= paths[i].length &lt;= 500</code></li>\n\t<li><code>1 &lt;= paths[i][j].length &lt;= 10</code></li>\n\t<li><code>1 &lt;= sum(paths[i][j].length) &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>path[i][j]</code> 由小写英文字母组成</li>\n\t<li>不会存在两个路径都指向同一个文件夹的情况</li>\n\t<li>对于不在根层级的任意文件夹，其父文件夹也会包含在输入中</li>\n</ul>\n", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class Solution {\npublic:\n    vector<vector<string>> deleteDuplicateFolder(vector<vector<string>>& paths) {\n        \n    }\n};"}, {"value": "java", "text": "Java", "defaultCode": "class Solution {\n    public List<List<String>> deleteDuplicateFolder(List<List<String>> paths) {\n        \n    }\n}"}, {"value": "python", "text": "Python", "defaultCode": "class Solution(object):\n    def deleteDuplicateFolder(self, paths):\n        \"\"\"\n        :type paths: List[List[str]]\n        :rtype: List[List[str]]\n        \"\"\"\n        "}, {"value": "python3", "text": "Python3", "defaultCode": "class Solution:\n    def deleteDuplicateFolder(self, paths: List[List[str]]) -> List[List[str]]:\n        "}, {"value": "c", "text": "C", "defaultCode": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nchar*** deleteDuplicateFolder(char*** paths, int pathsSize, int* pathsColSize, int* returnSize, int** returnColumnSizes) {\n    \n}"}, {"value": "csharp", "text": "C#", "defaultCode": "public class Solution {\n    public IList<IList<string>> DeleteDuplicateFolder(IList<IList<string>> paths) {\n        \n    }\n}"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * @param {string[][]} paths\n * @return {string[][]}\n */\nvar deleteDuplicateFolder = function(paths) {\n    \n};"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "function deleteDuplicateFolder(paths: string[][]): string[][] {\n    \n};"}, {"value": "php", "text": "PHP", "defaultCode": "class Solution {\n\n    /**\n     * @param String[][] $paths\n     * @return String[][]\n     */\n    function deleteDuplicateFolder($paths) {\n        \n    }\n}"}, {"value": "swift", "text": "Swift", "defaultCode": "class Solution {\n    func deleteDuplicateFolder(_ paths: [[String]]) -> [[String]] {\n        \n    }\n}"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class Solution {\n    fun deleteDuplicateFolder(paths: List<List<String>>): List<List<String>> {\n        \n    }\n}"}, {"value": "dart", "text": "Dart", "defaultCode": "class Solution {\n  List<List<String>> deleteDuplicateFolder(List<List<String>> paths) {\n    \n  }\n}"}, {"value": "golang", "text": "Go", "defaultCode": "func deleteDuplicateFolder(paths [][]string) [][]string {\n    \n}"}, {"value": "ruby", "text": "Ruby", "defaultCode": "# @param {String[][]} paths\n# @return {String[][]}\ndef delete_duplicate_folder(paths)\n    \nend"}, {"value": "scala", "text": "Scala", "defaultCode": "object Solution {\n    def deleteDuplicateFolder(paths: List[List[String]]): List[List[String]] = {\n        \n    }\n}"}, {"value": "rust", "text": "Rust", "defaultCode": "impl Solution {\n    pub fn delete_duplicate_folder(paths: Vec<Vec<String>>) -> Vec<Vec<String>> {\n        \n    }\n}"}, {"value": "racket", "text": "Racket", "defaultCode": "(define/contract (delete-duplicate-folder paths)\n  (-> (listof (listof string?)) (listof (listof string?)))\n  )"}, {"value": "erlang", "text": "Erlang", "defaultCode": "-spec delete_duplicate_folder(Paths :: [[unicode:unicode_binary()]]) -> [[unicode:unicode_binary()]].\ndelete_duplicate_folder(Paths) ->\n  ."}, {"value": "elixir", "text": "Elixir", "defaultCode": "defmodule Solution do\n  @spec delete_duplicate_folder(paths :: [[String.t]]) :: [[String.t]]\n  def delete_duplicate_folder(paths) do\n    \n  end\nend"}, {"value": "cangjie", "text": "Cangjie", "defaultCode": "class Solution {\n    func deleteDuplicateFolder(paths: ArrayList<ArrayList<String>>): ArrayList<ArrayList<String>> {\n\n    }\n}"}]}