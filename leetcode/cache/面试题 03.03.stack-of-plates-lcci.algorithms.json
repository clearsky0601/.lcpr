{"id": "面试题 03.03", "fid": "面试题 03.03", "name": "堆盘子", "slug": "stack-of-plates-lcci", "link": "https://leetcode.cn/problems/stack-of-plates-lcci/description/", "percent": 0, "level": "Medium", "category": "algorithms", "en_name": "Stack of Plates LCCI", "cn_name": "堆盘子", "desc": "<p>堆盘子。设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构<code>SetOfStacks</code>，模拟这种行为。<code>SetOfStacks</code>应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，<code>SetOfStacks.push()</code>和<code>SetOfStacks.pop()</code>应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）。 进阶：实现一个<code>popAt(int index)</code>方法，根据指定的子栈，执行pop操作。</p>\n\n<p>当某个栈为空时，应当删除该栈。当栈中没有元素或不存在该栈时，<code>pop</code>，<code>popAt</code>&nbsp;应返回 -1.</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong> 输入</strong>：\n[\"StackOfPlates\", \"push\", \"push\", \"popAt\", \"pop\", \"pop\"]\n[[1], [1], [2], [1], [], []]\n<strong> 输出</strong>：\n[null, null, null, 2, 1, -1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong> 输入</strong>：\n[\"StackOfPlates\", \"push\", \"push\", \"push\", \"popAt\", \"popAt\", \"popAt\"]\n[[2], [1], [2], [3], [0], [0], [0]]\n<strong> 输出</strong>：\n[null, null, null, null, 2, 1, 3]\n</pre>\n", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class StackOfPlates {\npublic:\n    StackOfPlates(int cap) {\n        \n    }\n    \n    void push(int val) {\n        \n    }\n    \n    int pop() {\n        \n    }\n    \n    int popAt(int index) {\n        \n    }\n};\n\n/**\n * Your StackOfPlates object will be instantiated and called as such:\n * StackOfPlates* obj = new StackOfPlates(cap);\n * obj->push(val);\n * int param_2 = obj->pop();\n * int param_3 = obj->popAt(index);\n */"}, {"value": "java", "text": "Java", "defaultCode": "class StackOfPlates {\n\n    public StackOfPlates(int cap) {\n        \n    }\n    \n    public void push(int val) {\n        \n    }\n    \n    public int pop() {\n        \n    }\n    \n    public int popAt(int index) {\n        \n    }\n}\n\n/**\n * Your StackOfPlates object will be instantiated and called as such:\n * StackOfPlates obj = new StackOfPlates(cap);\n * obj.push(val);\n * int param_2 = obj.pop();\n * int param_3 = obj.popAt(index);\n */"}, {"value": "python", "text": "Python", "defaultCode": "class StackOfPlates(object):\n\n    def __init__(self, cap):\n        \"\"\"\n        :type cap: int\n        \"\"\"\n        \n\n    def push(self, val):\n        \"\"\"\n        :type val: int\n        :rtype: None\n        \"\"\"\n        \n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def popAt(self, index):\n        \"\"\"\n        :type index: int\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your StackOfPlates object will be instantiated and called as such:\n# obj = StackOfPlates(cap)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAt(index)"}, {"value": "python3", "text": "Python3", "defaultCode": "class StackOfPlates:\n\n    def __init__(self, cap: int):\n        \n\n    def push(self, val: int) -> None:\n        \n\n    def pop(self) -> int:\n        \n\n    def popAt(self, index: int) -> int:\n        \n\n\n# Your StackOfPlates object will be instantiated and called as such:\n# obj = StackOfPlates(cap)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAt(index)"}, {"value": "c", "text": "C", "defaultCode": "\n\n\ntypedef struct {\n    \n} StackOfPlates;\n\n\nStackOfPlates* stackOfPlatesCreate(int cap) {\n    \n}\n\nvoid stackOfPlatesPush(StackOfPlates* obj, int val) {\n    \n}\n\nint stackOfPlatesPop(StackOfPlates* obj) {\n    \n}\n\nint stackOfPlatesPopAt(StackOfPlates* obj, int index) {\n    \n}\n\nvoid stackOfPlatesFree(StackOfPlates* obj) {\n    \n}\n\n/**\n * Your StackOfPlates struct will be instantiated and called as such:\n * StackOfPlates* obj = stackOfPlatesCreate(cap);\n * stackOfPlatesPush(obj, val);\n \n * int param_2 = stackOfPlatesPop(obj);\n \n * int param_3 = stackOfPlatesPopAt(obj, index);\n \n * stackOfPlatesFree(obj);\n*/"}, {"value": "csharp", "text": "C#", "defaultCode": "public class StackOfPlates {\n\n    public StackOfPlates(int cap) {\n        \n    }\n    \n    public void Push(int val) {\n        \n    }\n    \n    public int Pop() {\n        \n    }\n    \n    public int PopAt(int index) {\n        \n    }\n}\n\n/**\n * Your StackOfPlates object will be instantiated and called as such:\n * StackOfPlates obj = new StackOfPlates(cap);\n * obj.Push(val);\n * int param_2 = obj.Pop();\n * int param_3 = obj.PopAt(index);\n */"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * @param {number} cap\n */\nvar StackOfPlates = function(cap) {\n    \n};\n\n/** \n * @param {number} val\n * @return {void}\n */\nStackOfPlates.prototype.push = function(val) {\n    \n};\n\n/**\n * @return {number}\n */\nStackOfPlates.prototype.pop = function() {\n    \n};\n\n/** \n * @param {number} index\n * @return {number}\n */\nStackOfPlates.prototype.popAt = function(index) {\n    \n};\n\n/** \n * Your StackOfPlates object will be instantiated and called as such:\n * var obj = new StackOfPlates(cap)\n * obj.push(val)\n * var param_2 = obj.pop()\n * var param_3 = obj.popAt(index)\n */"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "class StackOfPlates {\n    constructor(cap: number) {\n        \n    }\n\n    push(val: number): void {\n        \n    }\n\n    pop(): number {\n        \n    }\n\n    popAt(index: number): number {\n        \n    }\n}\n\n/**\n * Your StackOfPlates object will be instantiated and called as such:\n * var obj = new StackOfPlates(cap)\n * obj.push(val)\n * var param_2 = obj.pop()\n * var param_3 = obj.popAt(index)\n */"}, {"value": "php", "text": "PHP", "defaultCode": "class StackOfPlates {\n    /**\n     * @param Integer $cap\n     */\n    function __construct($cap) {\n        \n    }\n  \n    /**\n     * @param Integer $val\n     * @return NULL\n     */\n    function push($val) {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function pop() {\n        \n    }\n  \n    /**\n     * @param Integer $index\n     * @return Integer\n     */\n    function popAt($index) {\n        \n    }\n}\n\n/**\n * Your StackOfPlates object will be instantiated and called as such:\n * $obj = StackOfPlates($cap);\n * $obj->push($val);\n * $ret_2 = $obj->pop();\n * $ret_3 = $obj->popAt($index);\n */"}, {"value": "swift", "text": "Swift", "defaultCode": "\nclass StackOfPlates {\n\n    init(_ cap: Int) {\n        \n    }\n    \n    func push(_ val: Int) {\n        \n    }\n    \n    func pop() -> Int {\n        \n    }\n    \n    func popAt(_ index: Int) -> Int {\n        \n    }\n}\n\n/**\n * Your StackOfPlates object will be instantiated and called as such:\n * let obj = StackOfPlates(cap)\n * obj.push(val)\n * let ret_2: Int = obj.pop()\n * let ret_3: Int = obj.popAt(index)\n */"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class StackOfPlates(cap: Int) {\n\n    fun push(`val`: Int) {\n        \n    }\n\n    fun pop(): Int {\n        \n    }\n\n    fun popAt(index: Int): Int {\n        \n    }\n\n}\n\n/**\n * Your StackOfPlates object will be instantiated and called as such:\n * var obj = StackOfPlates(cap)\n * obj.push(`val`)\n * var param_2 = obj.pop()\n * var param_3 = obj.popAt(index)\n */"}, {"value": "dart", "text": "Dart", "defaultCode": "class StackOfPlates {\n\n  StackOfPlates(int cap) {\n    \n  }\n  \n  void push(int val) {\n    \n  }\n  \n  int pop() {\n    \n  }\n  \n  int popAt(int index) {\n    \n  }\n}\n\n/**\n * Your StackOfPlates object will be instantiated and called as such:\n * StackOfPlates obj = StackOfPlates(cap);\n * obj.push(val);\n * int param2 = obj.pop();\n * int param3 = obj.popAt(index);\n */"}, {"value": "golang", "text": "Go", "defaultCode": "type StackOfPlates struct {\n    \n}\n\n\nfunc Constructor(cap int) StackOfPlates {\n    \n}\n\n\nfunc (this *StackOfPlates) Push(val int)  {\n    \n}\n\n\nfunc (this *StackOfPlates) Pop() int {\n    \n}\n\n\nfunc (this *StackOfPlates) PopAt(index int) int {\n    \n}\n\n\n/**\n * Your StackOfPlates object will be instantiated and called as such:\n * obj := Constructor(cap);\n * obj.Push(val);\n * param_2 := obj.Pop();\n * param_3 := obj.PopAt(index);\n */"}, {"value": "ruby", "text": "Ruby", "defaultCode": "class StackOfPlates\n\n=begin\n    :type cap: Integer\n=end\n    def initialize(cap)\n        \n    end\n\n\n=begin\n    :type val: Integer\n    :rtype: Void\n=end\n    def push(val)\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def pop()\n        \n    end\n\n\n=begin\n    :type index: Integer\n    :rtype: Integer\n=end\n    def pop_at(index)\n        \n    end\n\n\nend\n\n# Your StackOfPlates object will be instantiated and called as such:\n# obj = StackOfPlates.new(cap)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.pop_at(index)"}, {"value": "scala", "text": "Scala", "defaultCode": "class StackOfPlates(_cap: Int) {\n\n    def push(`val`: Int): Unit = {\n        \n    }\n\n    def pop(): Int = {\n        \n    }\n\n    def popAt(index: Int): Int = {\n        \n    }\n\n}\n\n/**\n * Your StackOfPlates object will be instantiated and called as such:\n * val obj = new StackOfPlates(cap)\n * obj.push(`val`)\n * val param_2 = obj.pop()\n * val param_3 = obj.popAt(index)\n */"}, {"value": "rust", "text": "Rust", "defaultCode": "struct StackOfPlates {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl StackOfPlates {\n\n    fn new(cap: i32) -> Self {\n        \n    }\n    \n    fn push(&self, val: i32) {\n        \n    }\n    \n    fn pop(&self) -> i32 {\n        \n    }\n    \n    fn pop_at(&self, index: i32) -> i32 {\n        \n    }\n}\n\n/**\n * Your StackOfPlates object will be instantiated and called as such:\n * let obj = StackOfPlates::new(cap);\n * obj.push(val);\n * let ret_2: i32 = obj.pop();\n * let ret_3: i32 = obj.pop_at(index);\n */"}, {"value": "racket", "text": "Racket", "defaultCode": "(define stack-of-plates%\n  (class object%\n    (super-new)\n    \n    ; cap : exact-integer?\n    (init-field\n      cap)\n    \n    ; push : exact-integer? -> void?\n    (define/public (push val)\n      )\n    ; pop : -> exact-integer?\n    (define/public (pop)\n      )\n    ; pop-at : exact-integer? -> exact-integer?\n    (define/public (pop-at index)\n      )))\n\n;; Your stack-of-plates% object will be instantiated and called as such:\n;; (define obj (new stack-of-plates% [cap cap]))\n;; (send obj push val)\n;; (define param_2 (send obj pop))\n;; (define param_3 (send obj pop-at index))"}, {"value": "erlang", "text": "Erlang", "defaultCode": "-spec stack_of_plates_init_(Cap :: integer()) -> any().\nstack_of_plates_init_(Cap) ->\n  .\n\n-spec stack_of_plates_push(Val :: integer()) -> any().\nstack_of_plates_push(Val) ->\n  .\n\n-spec stack_of_plates_pop() -> integer().\nstack_of_plates_pop() ->\n  .\n\n-spec stack_of_plates_pop_at(Index :: integer()) -> integer().\nstack_of_plates_pop_at(Index) ->\n  .\n\n\n%% Your functions will be called as such:\n%% stack_of_plates_init_(Cap),\n%% stack_of_plates_push(Val),\n%% Param_2 = stack_of_plates_pop(),\n%% Param_3 = stack_of_plates_pop_at(Index),\n\n%% stack_of_plates_init_ will be called before every test case, in which you can do some necessary initializations."}, {"value": "elixir", "text": "Elixir", "defaultCode": "defmodule StackOfPlates do\n  @spec init_(cap :: integer) :: any\n  def init_(cap) do\n    \n  end\n\n  @spec push(val :: integer) :: any\n  def push(val) do\n    \n  end\n\n  @spec pop() :: integer\n  def pop() do\n    \n  end\n\n  @spec pop_at(index :: integer) :: integer\n  def pop_at(index) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# StackOfPlates.init_(cap)\n# StackOfPlates.push(val)\n# param_2 = StackOfPlates.pop()\n# param_3 = StackOfPlates.pop_at(index)\n\n# StackOfPlates.init_ will be called before every test case, in which you can do some necessary initializations."}, {"value": "cangjie", "text": "Cangjie", "defaultCode": "class StackOfPlates {\n    init(cap: Int64) {\n\n    }\n    \n    func push(val: Int64): Unit {\n\n    }\n    \n    func pop(): Int64 {\n\n    }\n    \n    func popAt(index: Int64): Int64 {\n\n    }\n}\n\n/**\n * Your StackOfPlates object will be instantiated and called as such:\n * let obj: StackOfPlates = StackOfPlates(cap)\n * obj.push(val)\n * let param_2 = obj.pop()\n * let param_3 = obj.popAt(index)\n */"}]}