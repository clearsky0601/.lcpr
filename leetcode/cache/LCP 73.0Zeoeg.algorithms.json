{"id": "LCP 73", "fid": "LCP 73", "name": "探险营地", "slug": "0Zeoeg", "link": "https://leetcode.cn/problems/0Zeoeg/description/", "percent": 0, "level": "Medium", "category": "algorithms", "en_name": "探险营地", "cn_name": "探险营地", "desc": "探险家小扣的行动轨迹，都将保存在记录仪中。`expeditions[i]` 表示小扣第 `i` 次探险记录，用一个字符串数组表示。其中的每个「营地」由大小写字母组成，通过子串 `->` 连接。\n> 例：\"Leet->code->Campsite\"，表示到访了 \"Leet\"、\"code\"、\"Campsite\" 三个营地。\n\n`expeditions[0]` 包含了初始小扣已知的所有营地；对于之后的第 `i` 次探险(即 `expeditions[i]` 且 i > 0)，如果记录中包含了之前均没出现的营地，则表示小扣 **新发现** 的营地。\n\n请你找出小扣发现新营地最多且索引最小的那次探险，并返回对应的记录索引。如果所有探险记录都没有发现新的营地，返回 `-1`\n\n**注意：**\n- 大小写不同的营地视为不同的营地；\n- 营地的名称长度均大于 `0`。\n\n**示例 1：**\n>输入：`expeditions = [\"leet->code\",\"leet->code->Campsite->Leet\",\"leet->code->leet->courier\"]`\n>\n>输出：`1`\n>\n>解释：\n>初始已知的所有营地为 \"leet\" 和 \"code\"\n>第 1 次，到访了 \"leet\"、\"code\"、\"Campsite\"、\"Leet\"，新发现营地 2 处：\"Campsite\"、\"Leet\"\n>第 2 次，到访了 \"leet\"、\"code\"、\"courier\"，新发现营地 1 处：\"courier\"\n>第 1 次探险发现的新营地数量最多，因此返回 `1`\n\n**示例 2：**\n>输入：`expeditions = [\"Alice->Dex\",\"\",\"Dex\"]`\n>\n>输出：`-1`\n>\n>解释：\n>初始已知的所有营地为 \"Alice\" 和 \"Dex\"\n>第 1 次，未到访任何营地；\n>第 2 次，到访了 \"Dex\"，未新发现营地；\n>因为两次探险均未发现新的营地，返回 `-1`\n\n**示例 3：**\n>输入：`expeditions = [\"\",\"Gryffindor->Slytherin->Gryffindor\",\"Hogwarts->Hufflepuff->Ravenclaw\"]`\n>\n>输出：`2`\n>\n>解释：\n>初始未发现任何营地；\n>第 1 次，到访 \"Gryffindor\"、\"Slytherin\" 营地，其中重复到访 \"Gryffindor\" 两次，\n>因此新发现营地为 2 处：\"Gryffindor\"、\"Slytherin\"\n>第 2 次，到访 \"Hogwarts\"、\"Hufflepuff\"、\"Ravenclaw\" 营地；\n>新发现营地 3 处：\"Hogwarts\"、\"Hufflepuff\"、\"Ravenclaw\"；\n>第 2 次探险发现的新营地数量最多，因此返回 `2`\n\n**提示：**\n- `1 <= expeditions.length <= 1000`\n- `0 <= expeditions[i].length <= 1000`\n- 探险记录中只包含大小写字母和子串\"->\"", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class Solution {\npublic:\n    int adventureCamp(vector<string>& expeditions) {\n\n    }\n};"}, {"value": "java", "text": "Java", "defaultCode": "class Solution {\n    public int adventureCamp(String[] expeditions) {\n\n    }\n}"}, {"value": "python", "text": "Python", "defaultCode": "class Solution(object):\n    def adventureCamp(self, expeditions):\n        \"\"\"\n        :type expeditions: List[str]\n        :rtype: int\n        \"\"\""}, {"value": "python3", "text": "Python3", "defaultCode": "class Solution:\n    def adventureCamp(self, expeditions: List[str]) -> int:"}, {"value": "c", "text": "C", "defaultCode": "int adventureCamp(char** expeditions, int expeditionsSize){\n\n}"}, {"value": "csharp", "text": "C#", "defaultCode": "public class Solution {\n    public int AdventureCamp(string[] expeditions) {\n\n    }\n}"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * @param {string[]} expeditions\n * @return {number}\n */\nvar adventureCamp = function(expeditions) {\n\n};"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "function adventureCamp(expeditions: string[]): number {\n\n};"}, {"value": "php", "text": "PHP", "defaultCode": "class Solution {\n\n    /**\n     * @param String[] $expeditions\n     * @return Integer\n     */\n    function adventureCamp($expeditions) {\n\n    }\n}"}, {"value": "swift", "text": "Swift", "defaultCode": "class Solution {\n    func adventureCamp(_ expeditions: [String]) -> Int {\n\n    }\n}"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class Solution {\n    fun adventureCamp(expeditions: Array<String>): Int {\n\n    }\n}"}, {"value": "dart", "text": "Dart", "defaultCode": "class Solution {\n  int adventureCamp(List<String> expeditions) {\n\n  }\n}"}, {"value": "golang", "text": "Go", "defaultCode": "func adventureCamp(expeditions []string) int {\n\n}"}, {"value": "ruby", "text": "Ruby", "defaultCode": "# @param {String[]} expeditions\n# @return {Integer}\ndef adventure_camp(expeditions)\n\nend"}, {"value": "scala", "text": "Scala", "defaultCode": "object Solution {\n    def adventureCamp(expeditions: Array[String]): Int = {\n\n    }\n}"}, {"value": "rust", "text": "Rust", "defaultCode": "impl Solution {\n    pub fn adventure_camp(expeditions: Vec<String>) -> i32 {\n\n    }\n}"}, {"value": "racket", "text": "Racket", "defaultCode": "(define/contract (adventure-camp expeditions)\n  (-> (listof string?) exact-integer?)\n\n  )"}, {"value": "erlang", "text": "Erlang", "defaultCode": "-spec adventure_camp(Expeditions :: [unicode:unicode_binary()]) -> integer().\nadventure_camp(Expeditions) ->\n  ."}, {"value": "elixir", "text": "Elixir", "defaultCode": "defmodule Solution do\n  @spec adventure_camp(expeditions :: [String.t]) :: integer\n  def adventure_camp(expeditions) do\n\n  end\nend"}]}