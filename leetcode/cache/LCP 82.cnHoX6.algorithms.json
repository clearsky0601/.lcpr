{"id": "LCP 82", "fid": "LCP 82", "name": "万灵之树", "slug": "cnHoX6", "link": "https://leetcode.cn/problems/cnHoX6/description/", "percent": 0, "level": "Hard", "category": "algorithms", "en_name": "万灵之树", "cn_name": "万灵之树", "desc": "探险家小扣终于来到了万灵之树前，挑战最后的谜题。\n已知小扣拥有足够数量的链接节点和 `n` 颗幻境宝石，`gem[i]` 表示第 `i` 颗宝石的数值。现在小扣需要使用这些链接节点和宝石组合成一颗二叉树，其组装规则为：\n- 链接节点将作为二叉树中的非叶子节点，且每个链接节点必须拥有 `2` 个子节点；\n- 幻境宝石将作为二叉树中的叶子节点，所有的幻境宝石都必须被使用。\n\n能量首先进入根节点，而后将按如下规则进行移动和记录：\n- 若能量首次到达该节点时：\n    - 记录数字 `1`；\n    - 若该节点为叶节点，将额外记录该叶节点的数值；\n- 若存在未到达的子节点，则选取未到达的一个子节点（优先选取左子节点）进入；\n- 若无子节点或所有子节点均到达过，此时记录 `9`，并回到当前节点的父节点（若存在）。\n\n如果最终记下的数依序连接成一个整数 `num`，满足 $num \\mod~p=target$，则视为解开谜题。\n请问有多少种二叉树的组装方案，可以使得最终记录下的数字可以解开谜题\n\n**注意：**\n- 两棵结构不同的二叉树，作为不同的组装方案\n- 两棵结构相同的二叉树且存在某个相同位置处的宝石编号不同，也作为不同的组装方案\n- 可能存在数值相同的两颗宝石\n\n**示例 1：**\n> 输入：`gem = [2,3]`\n> `p = 100000007`\n> `target = 11391299`\n>\n> 输出：`1`\n>\n> 解释：\n> 包含 `2` 个叶节点的结构只有一种。\n> 假设 B、C 节点的值分别为 3、2，对应 target 为 11391299，如下图所示。\n> 11391299 % 100000007 = 11391299，满足条件;\n> 假设 B、C 节点的值分别为 2、3，对应 target 为 11291399;\n> 11291399 % 100000007 = 11291399，不满足条件；\n> 因此只存在 1 种方案，返回 1\n![万灵 (1).gif](https://pic.leetcode.cn/1682397079-evMssw-%E4%B8%87%E7%81%B5%20\\(1\\).gif){:height=300px}\n\n\n**示例 2：**\n> 输入：`gem = [3,21,3]`\n> `p = 7`\n> `target = 5`\n>\n> 输出：`4`\n>\n> 解释：\n包含 `3` 个叶节点树结构有两种，列举如下：\n满足条件的组合有四种情况：\n> 当结构为下图（1）时：叶子节点的值为 [3,3,21] 或 [3,3,21]，得到的整数为 `11139139912199`。\n> 当结构为下图（2）时：叶子节点的值为 [21,3,3] 或 [21,3,3]，得到的整数为 `11219113913999`。\n![image.png](https://pic.leetcode.cn/1682322894-vfqJIV-image.png){:width=500px}\n\n\n**提示：**\n- `1 <= gem.length <= 9`\n- `0 <= gem[i] <= 10^9`\n- `1 <= p <= 10^9`，保证 $p$ 为素数。\n- `0 <= target < p`\n- 存在 2 组 `gem.length == 9` 的用例", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class Solution {\npublic:\n    int treeOfInfiniteSouls(vector<int>& gem, int p, int target) {\n        \n    }\n};"}, {"value": "java", "text": "Java", "defaultCode": "class Solution {\n    public int treeOfInfiniteSouls(int[] gem, int p, int target) {\n        \n    }\n}"}, {"value": "python", "text": "Python", "defaultCode": "class Solution(object):\n    def treeOfInfiniteSouls(self, gem, p, target):\n        \"\"\"\n        :type gem: List[int]\n        :type p: int\n        :type target: int\n        :rtype: int\n        \"\"\"\n        "}, {"value": "python3", "text": "Python3", "defaultCode": "class Solution:\n    def treeOfInfiniteSouls(self, gem: List[int], p: int, target: int) -> int:\n        "}, {"value": "c", "text": "C", "defaultCode": "int treeOfInfiniteSouls(int* gem, int gemSize, int p, int target) {\n    \n}"}, {"value": "csharp", "text": "C#", "defaultCode": "public class Solution {\n    public int TreeOfInfiniteSouls(int[] gem, int p, int target) {\n        \n    }\n}"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * @param {number[]} gem\n * @param {number} p\n * @param {number} target\n * @return {number}\n */\nvar treeOfInfiniteSouls = function(gem, p, target) {\n    \n};"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "function treeOfInfiniteSouls(gem: number[], p: number, target: number): number {\n    \n};"}, {"value": "php", "text": "PHP", "defaultCode": "class Solution {\n\n    /**\n     * @param Integer[] $gem\n     * @param Integer $p\n     * @param Integer $target\n     * @return Integer\n     */\n    function treeOfInfiniteSouls($gem, $p, $target) {\n        \n    }\n}"}, {"value": "swift", "text": "Swift", "defaultCode": "class Solution {\n    func treeOfInfiniteSouls(_ gem: [Int], _ p: Int, _ target: Int) -> Int {\n        \n    }\n}"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class Solution {\n    fun treeOfInfiniteSouls(gem: IntArray, p: Int, target: Int): Int {\n        \n    }\n}"}, {"value": "dart", "text": "Dart", "defaultCode": "class Solution {\n  int treeOfInfiniteSouls(List<int> gem, int p, int target) {\n    \n  }\n}"}, {"value": "golang", "text": "Go", "defaultCode": "func treeOfInfiniteSouls(gem []int, p int, target int) int {\n    \n}"}, {"value": "ruby", "text": "Ruby", "defaultCode": "# @param {Integer[]} gem\n# @param {Integer} p\n# @param {Integer} target\n# @return {Integer}\ndef tree_of_infinite_souls(gem, p, target)\n    \nend"}, {"value": "scala", "text": "Scala", "defaultCode": "object Solution {\n    def treeOfInfiniteSouls(gem: Array[Int], p: Int, target: Int): Int = {\n        \n    }\n}"}, {"value": "rust", "text": "Rust", "defaultCode": "impl Solution {\n    pub fn tree_of_infinite_souls(gem: Vec<i32>, p: i32, target: i32) -> i32 {\n        \n    }\n}"}, {"value": "racket", "text": "Racket", "defaultCode": "(define/contract (tree-of-infinite-souls gem p target)\n  (-> (listof exact-integer?) exact-integer? exact-integer? exact-integer?)\n  )"}, {"value": "erlang", "text": "Erlang", "defaultCode": "-spec tree_of_infinite_souls(Gem :: [integer()], P :: integer(), Target :: integer()) -> integer().\ntree_of_infinite_souls(Gem, P, Target) ->\n  ."}, {"value": "elixir", "text": "Elixir", "defaultCode": "defmodule Solution do\n  @spec tree_of_infinite_souls(gem :: [integer], p :: integer, target :: integer) :: integer\n  def tree_of_infinite_souls(gem, p, target) do\n    \n  end\nend"}]}