{"id":100201,"fid":"面试题 08.10","name":"颜色填充","slug":"color-fill-lcci","link":"https://leetcode.cn/problems/color-fill-lcci/description/","percent":56.10041334811977,"level":"Easy","category":"LCCI","en_name":"Color Fill LCCI","cn_name":"颜色填充","totalAC":"28.1K","totalSubmit":"50K","likes":67,"dislikes":0,"desc":"<p>编写函数，实现许多图片编辑软件都支持的「颜色填充」功能。</p>\n\n<p>待填充的图像用二维数组 <code>image</code> 表示，元素为初始颜色值。初始坐标点的行坐标为 <code>sr</code> 列坐标为 <code>sc</code>。需要填充的新颜色为 <code>newColor</code> 。</p>\n\n<p>「周围区域」是指颜色相同且在上、下、左、右四个方向上存在相连情况的若干元素。</p>\n\n<p>请用新颜色填充初始坐标点的周围区域，并返回填充后的图像。</p>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>：\nimage = [[1,1,1],[1,1,0],[1,0,1]] \nsr = 1, sc = 1, newColor = 2\n<strong>输出</strong>：[[2,2,2],[2,2,0],[2,0,1]]\n<strong>解释</strong>: \n初始坐标点位于图像的正中间，坐标 (sr,sc)=(1,1) 。\n初始坐标点周围区域上所有符合条件的像素点的颜色都被更改成 2 。\n注意，右下角的像素没有更改为 2 ，因为它不属于初始坐标点的周围区域。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>image</code> 和 <code>image[0]</code> 的长度均在范围 [1, 50] 内。</li>\n\t<li>初始坐标点 <code>(sr,sc)</code> 满足 <code>0 <= sr < image.length</code> 和 <code>0 <= sc < image[0].length</code> 。</li>\n\t<li><code>image[i][j]</code> 和 <code>newColor</code> 表示的颜色值在范围 <code>[0, 65535]</code> 内。</li>\n</ul>\n","templates":[{"value":"cpp","text":"C++","defaultCode":"class Solution {\npublic:\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\n        \n    }\n};"},{"value":"java","text":"Java","defaultCode":"class Solution {\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n        \n    }\n}"},{"value":"python","text":"Python","defaultCode":"class Solution(object):\n    def floodFill(self, image, sr, sc, newColor):\n        \"\"\"\n        :type image: List[List[int]]\n        :type sr: int\n        :type sc: int\n        :type newColor: int\n        :rtype: List[List[int]]\n        \"\"\"\n        "},{"value":"python3","text":"Python3","defaultCode":"class Solution:\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\n        "},{"value":"c","text":"C","defaultCode":"/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** floodFill(int** image, int imageSize, int* imageColSize, int sr, int sc, int newColor, int* returnSize, int** returnColumnSizes) {\n    \n}"},{"value":"csharp","text":"C#","defaultCode":"public class Solution {\n    public int[][] FloodFill(int[][] image, int sr, int sc, int newColor) {\n        \n    }\n}"},{"value":"javascript","text":"JavaScript","defaultCode":"/**\n * @param {number[][]} image\n * @param {number} sr\n * @param {number} sc\n * @param {number} newColor\n * @return {number[][]}\n */\nvar floodFill = function(image, sr, sc, newColor) {\n    \n};"},{"value":"typescript","text":"TypeScript","defaultCode":"function floodFill(image: number[][], sr: number, sc: number, newColor: number): number[][] {\n    \n};"},{"value":"php","text":"PHP","defaultCode":"class Solution {\n\n    /**\n     * @param Integer[][] $image\n     * @param Integer $sr\n     * @param Integer $sc\n     * @param Integer $newColor\n     * @return Integer[][]\n     */\n    function floodFill($image, $sr, $sc, $newColor) {\n        \n    }\n}"},{"value":"swift","text":"Swift","defaultCode":"class Solution {\n    func floodFill(_ image: [[Int]], _ sr: Int, _ sc: Int, _ newColor: Int) -> [[Int]] {\n        \n    }\n}"},{"value":"kotlin","text":"Kotlin","defaultCode":"class Solution {\n    fun floodFill(image: Array<IntArray>, sr: Int, sc: Int, newColor: Int): Array<IntArray> {\n        \n    }\n}"},{"value":"dart","text":"Dart","defaultCode":"class Solution {\n  List<List<int>> floodFill(List<List<int>> image, int sr, int sc, int newColor) {\n    \n  }\n}"},{"value":"golang","text":"Go","defaultCode":"func floodFill(image [][]int, sr int, sc int, newColor int) [][]int {\n    \n}"},{"value":"ruby","text":"Ruby","defaultCode":"# @param {Integer[][]} image\n# @param {Integer} sr\n# @param {Integer} sc\n# @param {Integer} new_color\n# @return {Integer[][]}\ndef flood_fill(image, sr, sc, new_color)\n    \nend"},{"value":"scala","text":"Scala","defaultCode":"object Solution {\n    def floodFill(image: Array[Array[Int]], sr: Int, sc: Int, newColor: Int): Array[Array[Int]] = {\n        \n    }\n}"},{"value":"rust","text":"Rust","defaultCode":"impl Solution {\n    pub fn flood_fill(image: Vec<Vec<i32>>, sr: i32, sc: i32, new_color: i32) -> Vec<Vec<i32>> {\n        \n    }\n}"},{"value":"racket","text":"Racket","defaultCode":"(define/contract (flood-fill image sr sc newColor)\n  (-> (listof (listof exact-integer?)) exact-integer? exact-integer? exact-integer? (listof (listof exact-integer?)))\n  )"},{"value":"erlang","text":"Erlang","defaultCode":"-spec flood_fill(Image :: [[integer()]], Sr :: integer(), Sc :: integer(), NewColor :: integer()) -> [[integer()]].\nflood_fill(Image, Sr, Sc, NewColor) ->\n  ."},{"value":"elixir","text":"Elixir","defaultCode":"defmodule Solution do\n  @spec flood_fill(image :: [[integer]], sr :: integer, sc :: integer, new_color :: integer) :: [[integer]]\n  def flood_fill(image, sr, sc, new_color) do\n    \n  end\nend"},{"value":"cangjie","text":"Cangjie","defaultCode":"class Solution {\n    func floodFill(image: Array<Array<Int64>>, sr: Int64, sc: Int64, newColor: Int64): Array<Array<Int64>> {\n\n    }\n}"}],"testcase":"[[1,1,1],[1,1,0],[1,0,1]]\n1\n1\n2","testable":true,"templateMeta":{"name":"floodFill","params":[{"name":"image","type":"integer[][]"},{"name":"sr","type":"integer"},{"name":"sc","type":"integer"},{"name":"newColor","type":"integer"}],"return":{"type":"integer[][]"}}}