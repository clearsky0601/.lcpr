{"id": 1754, "fid": "1754", "name": "构造字典序最大的合并字符串", "slug": "largest-merge-of-two-strings", "link": "https://leetcode.cn/problems/largest-merge-of-two-strings/description/", "percent": 0, "level": "Medium", "category": "algorithms", "en_name": "Largest Merge Of Two Strings", "cn_name": "构造字典序最大的合并字符串", "desc": "<p>给你两个字符串 <code>word1</code> 和 <code>word2</code> 。你需要按下述方式构造一个新字符串 <code>merge</code> ：如果 <code>word1</code> 或 <code>word2</code> 非空，选择 <strong>下面选项之一</strong> 继续操作：</p>\n\n<ul>\n\t<li>如果 <code>word1</code> 非空，将 <code>word1</code> 中的第一个字符附加到 <code>merge</code> 的末尾，并将其从 <code>word1</code> 中移除。\n\n\t<ul>\n\t\t<li>例如，<code>word1 = \"abc\" </code>且 <code>merge = \"dv\"</code> ，在执行此选项操作之后，<code>word1 = \"bc\"</code> ，同时 <code>merge = \"dva\"</code> 。</li>\n\t</ul>\n\t</li>\n\t<li>如果 <code>word2</code> 非空，将 <code>word2</code> 中的第一个字符附加到 <code>merge</code> 的末尾，并将其从 <code>word2</code> 中移除。\n\t<ul>\n\t\t<li>例如，<code>word2 = \"abc\" </code>且 <code>merge = \"\"</code> ，在执行此选项操作之后，<code>word2 = \"bc\"</code> ，同时 <code>merge = \"a\"</code> 。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>返回你可以构造的字典序 <strong>最大</strong> 的合并字符串<em> </em><code>merge</code><em> 。</em></p>\n\n<p>长度相同的两个字符串 <code>a</code> 和 <code>b</code> 比较字典序大小，如果在 <code>a</code> 和 <code>b</code> 出现不同的第一个位置，<code>a</code> 中字符在字母表中的出现顺序位于 <code>b</code> 中相应字符之后，就认为字符串 <code>a</code> 按字典序比字符串 <code>b</code> 更大。例如，<code>\"abcd\"</code> 按字典序比 <code>\"abcc\"</code> 更大，因为两个字符串出现不同的第一个位置是第四个字符，而 <code>d</code> 在字母表中的出现顺序位于 <code>c</code> 之后。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"cabaa\", word2 = \"bcaaa\"\n<strong>输出：</strong>\"cbcabaaaaa\"\n<strong>解释：</strong>构造字典序最大的合并字符串，可行的一种方法如下所示：\n- 从 word1 中取第一个字符：merge = \"c\"，word1 = \"abaa\"，word2 = \"bcaaa\"\n- 从 word2 中取第一个字符：merge = \"cb\"，word1 = \"abaa\"，word2 = \"caaa\"\n- 从 word2 中取第一个字符：merge = \"cbc\"，word1 = \"abaa\"，word2 = \"aaa\"\n- 从 word1 中取第一个字符：merge = \"cbca\"，word1 = \"baa\"，word2 = \"aaa\"\n- 从 word1 中取第一个字符：merge = \"cbcab\"，word1 = \"aa\"，word2 = \"aaa\"\n- 将 word1 和 word2 中剩下的 5 个 a 附加到 merge 的末尾。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"abcabc\", word2 = \"abdcaba\"\n<strong>输出：</strong>\"abdcabcabcaba\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= word1.length, word2.length <= 3000</code></li>\n\t<li><code>word1</code> 和 <code>word2</code> 仅由小写英文组成</li>\n</ul>\n", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class Solution {\npublic:\n    string largestMerge(string word1, string word2) {\n        \n    }\n};"}, {"value": "java", "text": "Java", "defaultCode": "class Solution {\n    public String largestMerge(String word1, String word2) {\n        \n    }\n}"}, {"value": "python", "text": "Python", "defaultCode": "class Solution(object):\n    def largestMerge(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: str\n        \"\"\"\n        "}, {"value": "python3", "text": "Python3", "defaultCode": "class Solution:\n    def largestMerge(self, word1: str, word2: str) -> str:\n        "}, {"value": "c", "text": "C", "defaultCode": "char* largestMerge(char* word1, char* word2) {\n    \n}"}, {"value": "csharp", "text": "C#", "defaultCode": "public class Solution {\n    public string LargestMerge(string word1, string word2) {\n        \n    }\n}"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * @param {string} word1\n * @param {string} word2\n * @return {string}\n */\nvar largestMerge = function(word1, word2) {\n    \n};"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "function largestMerge(word1: string, word2: string): string {\n    \n};"}, {"value": "php", "text": "PHP", "defaultCode": "class Solution {\n\n    /**\n     * @param String $word1\n     * @param String $word2\n     * @return String\n     */\n    function largestMerge($word1, $word2) {\n        \n    }\n}"}, {"value": "swift", "text": "Swift", "defaultCode": "class Solution {\n    func largestMerge(_ word1: String, _ word2: String) -> String {\n        \n    }\n}"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class Solution {\n    fun largestMerge(word1: String, word2: String): String {\n        \n    }\n}"}, {"value": "dart", "text": "Dart", "defaultCode": "class Solution {\n  String largestMerge(String word1, String word2) {\n    \n  }\n}"}, {"value": "golang", "text": "Go", "defaultCode": "func largestMerge(word1 string, word2 string) string {\n    \n}"}, {"value": "ruby", "text": "Ruby", "defaultCode": "# @param {String} word1\n# @param {String} word2\n# @return {String}\ndef largest_merge(word1, word2)\n    \nend"}, {"value": "scala", "text": "Scala", "defaultCode": "object Solution {\n    def largestMerge(word1: String, word2: String): String = {\n        \n    }\n}"}, {"value": "rust", "text": "Rust", "defaultCode": "impl Solution {\n    pub fn largest_merge(word1: String, word2: String) -> String {\n        \n    }\n}"}, {"value": "racket", "text": "Racket", "defaultCode": "(define/contract (largest-merge word1 word2)\n  (-> string? string? string?)\n  )"}, {"value": "erlang", "text": "Erlang", "defaultCode": "-spec largest_merge(Word1 :: unicode:unicode_binary(), Word2 :: unicode:unicode_binary()) -> unicode:unicode_binary().\nlargest_merge(Word1, Word2) ->\n  ."}, {"value": "elixir", "text": "Elixir", "defaultCode": "defmodule Solution do\n  @spec largest_merge(word1 :: String.t, word2 :: String.t) :: String.t\n  def largest_merge(word1, word2) do\n    \n  end\nend"}, {"value": "cangjie", "text": "Cangjie", "defaultCode": "class Solution {\n    func largestMerge(word1: String, word2: String): String {\n\n    }\n}"}]}