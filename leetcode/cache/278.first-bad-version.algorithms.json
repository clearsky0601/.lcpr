{"id": 278, "fid": "278", "name": "第一个错误的版本", "slug": "first-bad-version", "link": "https://leetcode.cn/problems/first-bad-version/description/", "percent": 0, "level": "Easy", "category": "algorithms", "en_name": "First Bad Version", "cn_name": "第一个错误的版本", "desc": "<p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>\n\n<p>假设你有 <code>n</code> 个版本 <code>[1, 2, ..., n]</code>，你想找出导致之后所有版本出错的第一个错误的版本。</p>\n\n<p>你可以通过调用&nbsp;<code>bool isBadVersion(version)</code>&nbsp;接口来判断版本号 <code>version</code> 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>\n&nbsp;\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, bad = 4\n<strong>输出：</strong>4\n<strong>解释：</strong>\n<code>调用 isBadVersion(3) -&gt; false \n调用 isBadVersion(5)&nbsp;-&gt; true \n调用 isBadVersion(4)&nbsp;-&gt; true</code>\n<code>所以，4 是第一个错误的版本。</code>\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, bad = 1\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= bad &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "// The API isBadVersion is defined for you.\n// bool isBadVersion(int version);\n\nclass Solution {\npublic:\n    int firstBadVersion(int n) {\n        \n    }\n};"}, {"value": "java", "text": "Java", "defaultCode": "/* The isBadVersion API is defined in the parent class VersionControl.\n      boolean isBadVersion(int version); */\n\npublic class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        \n    }\n}"}, {"value": "python", "text": "Python", "defaultCode": "# The isBadVersion API is already defined for you.\n# @param version, an integer\n# @return a bool\n# def isBadVersion(version):\n\nclass Solution(object):\n    def firstBadVersion(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        "}, {"value": "python3", "text": "Python3", "defaultCode": "# The isBadVersion API is already defined for you.\n# def isBadVersion(version: int) -> bool:\n\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        "}, {"value": "c", "text": "C", "defaultCode": "// The API isBadVersion is defined for you.\n// bool isBadVersion(int version);\n\nint firstBadVersion(int n) {\n    \n}"}, {"value": "csharp", "text": "C#", "defaultCode": "/* The isBadVersion API is defined in the parent class VersionControl.\n      bool IsBadVersion(int version); */\n\npublic class Solution : VersionControl {\n    public int FirstBadVersion(int n) {\n        \n    }\n}"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * Definition for isBadVersion()\n * \n * @param {integer} version number\n * @return {boolean} whether the version is bad\n * isBadVersion = function(version) {\n *     ...\n * };\n */\n\n/**\n * @param {function} isBadVersion()\n * @return {function}\n */\nvar solution = function(isBadVersion) {\n    /**\n     * @param {integer} n Total versions\n     * @return {integer} The first bad version\n     */\n    return function(n) {\n        \n    };\n};"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "/**\n * The knows API is defined in the parent class Relation.\n * isBadVersion(version: number): boolean {\n *     ...\n * };\n */\n\nvar solution = function(isBadVersion: any) {\n\n    return function(n: number): number {\n        \n    };\n};"}, {"value": "php", "text": "PHP", "defaultCode": "/* The isBadVersion API is defined in the parent class VersionControl.\n      public function isBadVersion($version){} */\n\nclass Solution extends VersionControl {\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function firstBadVersion($n) {\n        \n    }\n}"}, {"value": "swift", "text": "Swift", "defaultCode": "/**\n * The knows API is defined in the parent class VersionControl.\n *     func isBadVersion(_ version: Int) -> Bool{}\n */\n\nclass Solution : VersionControl {\n    func firstBadVersion(_ n: Int) -> Int {\n        \n    }\n}"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "/* The isBadVersion API is defined in the parent class VersionControl.\n      fun isBadVersion(version: Int) : Boolean {} */\n\nclass Solution: VersionControl() {\n    override fun firstBadVersion(n: Int) : Int {\n        \n\t}\n}"}, {"value": "golang", "text": "Go", "defaultCode": "/** \n * Forward declaration of isBadVersion API.\n * @param   version   your guess about first bad version\n * @return \t \t      true if current version is bad \n *\t\t\t          false if current version is good\n * func isBadVersion(version int) bool;\n */\n\nfunc firstBadVersion(n int) int {\n    \n}"}, {"value": "ruby", "text": "Ruby", "defaultCode": "# The is_bad_version API is already defined for you.\n# @param {Integer} version\n# @return {boolean} whether the version is bad\n# def is_bad_version(version):\n\n# @param {Integer} n\n# @return {Integer}\ndef first_bad_version(n)\n    \nend"}, {"value": "scala", "text": "Scala", "defaultCode": "/* The isBadVersion API is defined in the parent class VersionControl.\n      def isBadVersion(version: Int): Boolean = {} */\n\nclass Solution extends VersionControl {\n    def firstBadVersion(n: Int): Int = {\n        \n    }\n}"}, {"value": "rust", "text": "Rust", "defaultCode": "// The API isBadVersion is defined for you.\n// isBadVersion(version:i32)-> bool;\n// to call it use self.isBadVersion(version)\n\nimpl Solution {\n    pub fn first_bad_version(&self, n: i32) -> i32 {\n\t\t\n    }\n}"}]}