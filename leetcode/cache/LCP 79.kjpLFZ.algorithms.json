{"id": "LCP 79", "fid": "LCP 79", "name": "提取咒文", "slug": "kjpLFZ", "link": "https://leetcode.cn/problems/kjpLFZ/description/", "percent": 0, "level": "Medium", "category": "algorithms", "en_name": "提取咒文", "cn_name": "提取咒文", "desc": "随着兽群逐渐远去，一座大升降机缓缓的从地下升到了远征队面前。借由这台升降机，他们将能够到达地底的永恒至森。\n在升降机的操作台上，是一个由魔法符号组成的矩阵，为了便于辨识，我们用小写字母来表示。 `matrix[i][j]` 表示矩阵第 `i` 行 `j` 列的字母。该矩阵上有一个提取装置，可以对所在位置的字母提取。\n提取装置初始位于矩阵的左上角 `[0,0]`，可以通过每次操作移动到上、下、左、右相邻的 1 格位置中。提取装置每次移动或每次提取均记为一次操作。\n\n远征队需要按照顺序，从矩阵中逐一取出字母以组成 `mantra`，才能够成功的启动升降机。请返回他们 **最少** 需要消耗的操作次数。如果无法完成提取，返回 `-1`。\n\n**注意：**\n- 提取装置可对同一位置的字母重复提取，每次提取一个\n- 提取字母时，需按词语顺序依次提取\n\n**示例 1：**\n>输入：`matrix = [\"sd\",\"ep\"], mantra = \"speed\"`\n>\n>输出：`10`\n>\n>解释：如下图所示\n![矩阵 (2).gif](https://pic.leetcode-cn.com/1646288670-OTlvAl-%E7%9F%A9%E9%98%B5%20\\(2\\).gif)\n\n**示例 2：**\n>输入：`matrix = [\"abc\",\"daf\",\"geg\"]， mantra = \"sad\"`\n>\n>输出：`-1`\n>\n>解释：矩阵中不存在 `s` ，无法提取词语\n\n**提示：**\n- `0 < matrix.length, matrix[i].length <= 100`\n- `0 < mantra.length <= 100`\n- `matrix 和 mantra` 仅由小写字母组成", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class Solution {\npublic:\n    int extractMantra(vector<string>& matrix, string mantra) {\n\n    }\n};"}, {"value": "java", "text": "Java", "defaultCode": "class Solution {\n    public int extractMantra(String[] matrix, String mantra) {\n\n    }\n}"}, {"value": "python", "text": "Python", "defaultCode": "class Solution(object):\n    def extractMantra(self, matrix, mantra):\n        \"\"\"\n        :type matrix: List[str]\n        :type mantra: str\n        :rtype: int\n        \"\"\""}, {"value": "python3", "text": "Python3", "defaultCode": "class Solution:\n    def extractMantra(self, matrix: List[str], mantra: str) -> int:"}, {"value": "c", "text": "C", "defaultCode": "int extractMantra(char** matrix, int matrixSize, char* mantra){\n\n}"}, {"value": "csharp", "text": "C#", "defaultCode": "public class Solution {\n    public int ExtractMantra(string[] matrix, string mantra) {\n\n    }\n}"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * @param {string[]} matrix\n * @param {string} mantra\n * @return {number}\n */\nvar extractMantra = function(matrix, mantra) {\n\n};"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "function extractMantra(matrix: string[], mantra: string): number {\n\n};"}, {"value": "php", "text": "PHP", "defaultCode": "class Solution {\n\n    /**\n     * @param String[] $matrix\n     * @param String $mantra\n     * @return Integer\n     */\n    function extractMantra($matrix, $mantra) {\n\n    }\n}"}, {"value": "swift", "text": "Swift", "defaultCode": "class Solution {\n    func extractMantra(_ matrix: [String], _ mantra: String) -> Int {\n\n    }\n}"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class Solution {\n    fun extractMantra(matrix: Array<String>, mantra: String): Int {\n\n    }\n}"}, {"value": "dart", "text": "Dart", "defaultCode": "class Solution {\n  int extractMantra(List<String> matrix, String mantra) {\n\n  }\n}"}, {"value": "golang", "text": "Go", "defaultCode": "func extractMantra(matrix []string, mantra string) int {\n\n}"}, {"value": "ruby", "text": "Ruby", "defaultCode": "# @param {String[]} matrix\n# @param {String} mantra\n# @return {Integer}\ndef extract_mantra(matrix, mantra)\n\nend"}, {"value": "scala", "text": "Scala", "defaultCode": "object Solution {\n    def extractMantra(matrix: Array[String], mantra: String): Int = {\n\n    }\n}"}, {"value": "rust", "text": "Rust", "defaultCode": "impl Solution {\n    pub fn extract_mantra(matrix: Vec<String>, mantra: String) -> i32 {\n\n    }\n}"}, {"value": "racket", "text": "Racket", "defaultCode": "(define/contract (extract-mantra matrix mantra)\n  (-> (listof string?) string? exact-integer?)\n\n  )"}, {"value": "erlang", "text": "Erlang", "defaultCode": "-spec extract_mantra(Matrix :: [unicode:unicode_binary()], Mantra :: unicode:unicode_binary()) -> integer().\nextract_mantra(Matrix, Mantra) ->\n  ."}, {"value": "elixir", "text": "Elixir", "defaultCode": "defmodule Solution do\n  @spec extract_mantra(matrix :: [String.t], mantra :: String.t) :: integer\n  def extract_mantra(matrix, mantra) do\n\n  end\nend"}]}