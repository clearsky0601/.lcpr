{"id": "LCP 81", "fid": "LCP 81", "name": "与非的谜题", "slug": "ryfUiz", "link": "https://leetcode.cn/problems/ryfUiz/description/", "percent": 0, "level": "Hard", "category": "algorithms", "en_name": "与非的谜题", "cn_name": "与非的谜题", "desc": "在永恒之森中，封存着有关万灵之树线索的卷轴，只要探险队通过最后的考验，便可以获取前往万灵之树的线索。\n\n探险队需要从一段不断变化的谜题数组中找到最终的密码，初始的谜题为长度为 `n` 的数组 `arr`（下标从 0 开始），数组中的数字代表了 `k` 位二进制数。\n破解谜题的过程中，需要使用 `与非（NAND）` 运算方式，`operations[i] = [type,x,y]` 表示第 `i` 次进行的谜题操作信息：\n- 若 `type = 0`，表示修改操作，将谜题数组中下标 `x` 的数字变化为 `y`；\n- 若 `type = 1`，表示运算操作，将数字 `y` 进行 `x*n` 次「与非」操作，第 `i` 次与非操作为 `y = y NAND arr[i%n]`；\n    > 运算操作结果即：`y NAND arr[0%n] NAND arr[1%n] NAND arr[2%n] ... NAND arr[(x*n-1)%n]`\n\n最后，将所有运算操作的结果按顺序逐一进行 `异或（XOR）`运算，从而得到最终解开封印的密码。请返回最终解开封印的密码。\n\n**注意:**\n- 「与非」（NAND）的操作为：先进行 `与` 操作，后进行 `非` 操作。\n    > 例如：两个三位二进制数`2`和`3`，其与非结果为 `NOT ((010) AND (011)) = (101) = 5`\n\n**示例 1：**\n> 输入: \n> `k = 3`\n> `arr = [1,2]`\n> `operations = [[1,2,3],[0,0,3],[1,2,2]]`\n>\n> 输出: `2`\n>\n> 解释：\n> 初始的谜题数组为 [1,2]，二进制位数为 3，\n> 第 0 次进行运算操作，将数字 3(011) 进行 2\\*2 次「与非」运算，\n> 运算操作结果为 `3 NAND 1 NAND 2 NAND 1 NAND 2 = 5`\n> 第 1 次进行修改操作，谜题数组的第 `0` 个数字变化为 `3`，谜题变成 `[3,2]`\n> 第 2 次进行运算操作，将数字 2(010) 进行 2\\*2 次「与非」运算，\n> 运算操作结果为 `2 NAND 3 NAND 2 NAND 3 NAND 2 = 7`\n> 所有运算操作结果进行「异或」运算为 `5 XOR 7 = 2`\n> 因此得到的最终密码为 `2`。\n\n**示例 2：**\n> 输入:\n> `k = 4`\n> `arr = [4,6,4,7,10,9,11]`\n> `operations = [[1,5,7],[1,7,14],[0,6,7],[1,6,5]]`\n> 输出: `9`\n> 解释: \n> 初始的谜题数组为 [4,6,4,7,10,9,11],\n> 第 0 次进行运算操作，运算操作结果为 5；\n> 第 1 次进行运算操作，运算操作结果为 5；\n> 第 2 次进行修改操作，修改后谜题数组为 [4, 6, 4, 7, 10, 9, 7]；\n> 第 3 次进行运算操作，运算操作结果为 9；\n> 所有运算操作结果进行「异或」运算为 `5 XOR 5 XOR 9 = 9`；\n> 因此得到的最终密码为 `9`。\n\n**提示:**\n- `1 <= arr.length, operations.length <= 10^4`\n- `1 <= k <= 30`\n- `0 <= arr[i] < 2^k`\n- 若 `type = 0`，`0 <= x < arr.length` 且 `0 <= y < 2^k`\n- 若 `type = 1`，`1 <= x < 10^9` 且 `0 <= y < 2^k`\n- 保证存在 `type = 1` 的操作\n", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class Solution {\npublic:\n    int getNandResult(int k, vector<int>& arr, vector<vector<int>>& operations) {\n\n    }\n};"}, {"value": "java", "text": "Java", "defaultCode": "class Solution {\n    public int getNandResult(int k, int[] arr, int[][] operations) {\n\n    }\n}"}, {"value": "python", "text": "Python", "defaultCode": "class Solution(object):\n    def getNandResult(self, k, arr, operations):\n        \"\"\"\n        :type k: int\n        :type arr: List[int]\n        :type operations: List[List[int]]\n        :rtype: int\n        \"\"\""}, {"value": "python3", "text": "Python3", "defaultCode": "class Solution:\n    def getNandResult(self, k: int, arr: List[int], operations: List[List[int]]) -> int:"}, {"value": "c", "text": "C", "defaultCode": "int getNandResult(int k, int* arr, int arrSize, int** operations, int operationsSize, int* operationsColSize){\n\n}"}, {"value": "csharp", "text": "C#", "defaultCode": "public class Solution {\n    public int GetNandResult(int k, int[] arr, int[][] operations) {\n\n    }\n}"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * @param {number} k\n * @param {number[]} arr\n * @param {number[][]} operations\n * @return {number}\n */\nvar getNandResult = function(k, arr, operations) {\n\n};"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "function getNandResult(k: number, arr: number[], operations: number[][]): number {\n\n};"}, {"value": "php", "text": "PHP", "defaultCode": "class Solution {\n\n    /**\n     * @param Integer $k\n     * @param Integer[] $arr\n     * @param Integer[][] $operations\n     * @return Integer\n     */\n    function getNandResult($k, $arr, $operations) {\n\n    }\n}"}, {"value": "swift", "text": "Swift", "defaultCode": "class Solution {\n    func getNandResult(_ k: Int, _ arr: [Int], _ operations: [[Int]]) -> Int {\n\n    }\n}"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class Solution {\n    fun getNandResult(k: Int, arr: IntArray, operations: Array<IntArray>): Int {\n\n    }\n}"}, {"value": "dart", "text": "Dart", "defaultCode": "class Solution {\n  int getNandResult(int k, List<int> arr, List<List<int>> operations) {\n\n  }\n}"}, {"value": "golang", "text": "Go", "defaultCode": "func getNandResult(k int, arr []int, operations [][]int) int {\n\n}"}, {"value": "ruby", "text": "Ruby", "defaultCode": "# @param {Integer} k\n# @param {Integer[]} arr\n# @param {Integer[][]} operations\n# @return {Integer}\ndef get_nand_result(k, arr, operations)\n\nend"}, {"value": "scala", "text": "Scala", "defaultCode": "object Solution {\n    def getNandResult(k: Int, arr: Array[Int], operations: Array[Array[Int]]): Int = {\n\n    }\n}"}, {"value": "rust", "text": "Rust", "defaultCode": "impl Solution {\n    pub fn get_nand_result(k: i32, arr: Vec<i32>, operations: Vec<Vec<i32>>) -> i32 {\n\n    }\n}"}, {"value": "racket", "text": "Racket", "defaultCode": "(define/contract (get-nand-result k arr operations)\n  (-> exact-integer? (listof exact-integer?) (listof (listof exact-integer?)) exact-integer?)\n\n  )"}, {"value": "erlang", "text": "Erlang", "defaultCode": "-spec get_nand_result(K :: integer(), Arr :: [integer()], Operations :: [[integer()]]) -> integer().\nget_nand_result(K, Arr, Operations) ->\n  ."}, {"value": "elixir", "text": "Elixir", "defaultCode": "defmodule Solution do\n  @spec get_nand_result(k :: integer, arr :: [integer], operations :: [[integer]]) :: integer\n  def get_nand_result(k, arr, operations) do\n\n  end\nend"}]}