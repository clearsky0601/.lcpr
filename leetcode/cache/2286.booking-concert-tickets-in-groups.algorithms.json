{"id": 2286, "fid": "2286", "name": "以组为单位订音乐会的门票", "slug": "booking-concert-tickets-in-groups", "link": "https://leetcode.cn/problems/booking-concert-tickets-in-groups/description/", "percent": 0, "level": "Hard", "category": "algorithms", "en_name": "Booking Concert Tickets in Groups", "cn_name": "以组为单位订音乐会的门票", "desc": "<p>一个音乐会总共有&nbsp;<code>n</code>&nbsp;排座位，编号从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;，每一排有&nbsp;<code>m</code>&nbsp;个座椅，编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>m - 1</code>&nbsp;。你需要设计一个买票系统，针对以下情况进行座位安排：</p>\n\n<ul>\n\t<li>同一组的 <code>k</code>&nbsp;位观众坐在<strong> 同一排座位，且座位连续 </strong>。</li>\n\t<li><code>k</code>&nbsp;位观众中 <strong>每一位</strong>&nbsp;都有座位坐，但他们 <strong>不一定</strong>&nbsp;坐在一起。</li>\n</ul>\n\n<p>由于观众非常挑剔，所以：</p>\n\n<ul>\n\t<li>只有当一个组里所有成员座位的排数都 <strong>小于等于</strong>&nbsp;<code>maxRow</code>&nbsp;，这个组才能订座位。每一组的&nbsp;<code>maxRow</code>&nbsp;可能 <strong>不同</strong>&nbsp;。</li>\n\t<li>如果有多排座位可以选择，优先选择 <strong>最小</strong>&nbsp;的排数。如果同一排中有多个座位可以坐，优先选择号码 <strong>最小</strong>&nbsp;的。</li>\n</ul>\n\n<p>请你实现&nbsp;<code>BookMyShow</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>BookMyShow(int n, int m)</code>&nbsp;，初始化对象，<code>n</code>&nbsp;是排数，<code>m</code>&nbsp;是每一排的座位数。</li>\n\t<li><code>int[] gather(int k, int maxRow)</code>&nbsp;返回长度为 <code>2</code>&nbsp;的数组，表示 <code>k</code>&nbsp;个成员中 <strong>第一个座位</strong>&nbsp;的排数和座位编号，这 <code>k</code>&nbsp;位成员必须坐在 <strong>同一排座位，且座位连续 </strong>。换言之，返回最小可能的&nbsp;<code>r</code> 和&nbsp;<code>c</code>&nbsp;满足第&nbsp;<code>r</code>&nbsp;排中&nbsp;<code>[c, c + k - 1]</code>&nbsp;的座位都是空的，且&nbsp;<code>r &lt;= maxRow</code>&nbsp;。如果&nbsp;<strong>无法</strong>&nbsp;安排座位，返回&nbsp;<code>[]</code>&nbsp;。</li>\n\t<li><code>boolean scatter(int k, int maxRow)</code>&nbsp;如果组里所有&nbsp;<code>k</code>&nbsp;个成员&nbsp;<strong>不一定</strong>&nbsp;要坐在一起的前提下，都能在第&nbsp;<code>0</code> 排到第&nbsp;<code>maxRow</code>&nbsp;排之间找到座位，那么请返回&nbsp;<code>true</code>&nbsp;。这种情况下，每个成员都优先找排数&nbsp;<strong>最小</strong>&nbsp;，然后是座位编号最小的座位。如果不能安排所有&nbsp;<code>k</code>&nbsp;个成员的座位，请返回&nbsp;<code>false</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"BookMyShow\", \"gather\", \"gather\", \"scatter\", \"scatter\"]\n[[2, 5], [4, 0], [2, 0], [5, 1], [5, 1]]\n<strong>输出：</strong>\n[null, [0, 0], [], true, false]\n\n<strong>解释：</strong>\nBookMyShow bms = new BookMyShow(2, 5); // 总共有 2 排，每排 5 个座位。\nbms.gather(4, 0); // 返回 [0, 0]\n                  // 这一组安排第 0 排 [0, 3] 的座位。\nbms.gather(2, 0); // 返回 []\n                  // 第 0 排只剩下 1 个座位。\n                  // 所以无法安排 2 个连续座位。\nbms.scatter(5, 1); // 返回 True\n                   // 这一组安排第 0 排第 4 个座位和第 1 排 [0, 3] 的座位。\nbms.scatter(5, 1); // 返回 False\n                   // 总共只剩下 1 个座位。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= m, k &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= maxRow &lt;= n - 1</code></li>\n\t<li><code>gather</code> 和&nbsp;<code>scatter</code>&nbsp;<strong>总</strong> 调用次数不超过&nbsp;<code>5 * 10<sup>4</sup></code> 次。</li>\n</ul>\n", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class BookMyShow {\npublic:\n    BookMyShow(int n, int m) {\n        \n    }\n    \n    vector<int> gather(int k, int maxRow) {\n        \n    }\n    \n    bool scatter(int k, int maxRow) {\n        \n    }\n};\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * BookMyShow* obj = new BookMyShow(n, m);\n * vector<int> param_1 = obj->gather(k,maxRow);\n * bool param_2 = obj->scatter(k,maxRow);\n */"}, {"value": "java", "text": "Java", "defaultCode": "class BookMyShow {\n\n    public BookMyShow(int n, int m) {\n        \n    }\n    \n    public int[] gather(int k, int maxRow) {\n        \n    }\n    \n    public boolean scatter(int k, int maxRow) {\n        \n    }\n}\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * BookMyShow obj = new BookMyShow(n, m);\n * int[] param_1 = obj.gather(k,maxRow);\n * boolean param_2 = obj.scatter(k,maxRow);\n */"}, {"value": "python", "text": "Python", "defaultCode": "class BookMyShow(object):\n\n    def __init__(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        \"\"\"\n        \n\n    def gather(self, k, maxRow):\n        \"\"\"\n        :type k: int\n        :type maxRow: int\n        :rtype: List[int]\n        \"\"\"\n        \n\n    def scatter(self, k, maxRow):\n        \"\"\"\n        :type k: int\n        :type maxRow: int\n        :rtype: bool\n        \"\"\"\n        \n\n\n# Your BookMyShow object will be instantiated and called as such:\n# obj = BookMyShow(n, m)\n# param_1 = obj.gather(k,maxRow)\n# param_2 = obj.scatter(k,maxRow)"}, {"value": "python3", "text": "Python3", "defaultCode": "class BookMyShow:\n\n    def __init__(self, n: int, m: int):\n        \n\n    def gather(self, k: int, maxRow: int) -> List[int]:\n        \n\n    def scatter(self, k: int, maxRow: int) -> bool:\n        \n\n\n# Your BookMyShow object will be instantiated and called as such:\n# obj = BookMyShow(n, m)\n# param_1 = obj.gather(k,maxRow)\n# param_2 = obj.scatter(k,maxRow)"}, {"value": "c", "text": "C", "defaultCode": "\n\n\ntypedef struct {\n    \n} BookMyShow;\n\n\nBookMyShow* bookMyShowCreate(int n, int m) {\n    \n}\n\nint* bookMyShowGather(BookMyShow* obj, int k, int maxRow, int* retSize) {\n    \n}\n\nbool bookMyShowScatter(BookMyShow* obj, int k, int maxRow) {\n    \n}\n\nvoid bookMyShowFree(BookMyShow* obj) {\n    \n}\n\n/**\n * Your BookMyShow struct will be instantiated and called as such:\n * BookMyShow* obj = bookMyShowCreate(n, m);\n * int* param_1 = bookMyShowGather(obj, k, maxRow, retSize);\n \n * bool param_2 = bookMyShowScatter(obj, k, maxRow);\n \n * bookMyShowFree(obj);\n*/"}, {"value": "csharp", "text": "C#", "defaultCode": "public class BookMyShow {\n\n    public BookMyShow(int n, int m) {\n        \n    }\n    \n    public int[] Gather(int k, int maxRow) {\n        \n    }\n    \n    public bool Scatter(int k, int maxRow) {\n        \n    }\n}\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * BookMyShow obj = new BookMyShow(n, m);\n * int[] param_1 = obj.Gather(k,maxRow);\n * bool param_2 = obj.Scatter(k,maxRow);\n */"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * @param {number} n\n * @param {number} m\n */\nvar BookMyShow = function(n, m) {\n    \n};\n\n/** \n * @param {number} k \n * @param {number} maxRow\n * @return {number[]}\n */\nBookMyShow.prototype.gather = function(k, maxRow) {\n    \n};\n\n/** \n * @param {number} k \n * @param {number} maxRow\n * @return {boolean}\n */\nBookMyShow.prototype.scatter = function(k, maxRow) {\n    \n};\n\n/** \n * Your BookMyShow object will be instantiated and called as such:\n * var obj = new BookMyShow(n, m)\n * var param_1 = obj.gather(k,maxRow)\n * var param_2 = obj.scatter(k,maxRow)\n */"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "class BookMyShow {\n    constructor(n: number, m: number) {\n        \n    }\n\n    gather(k: number, maxRow: number): number[] {\n        \n    }\n\n    scatter(k: number, maxRow: number): boolean {\n        \n    }\n}\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * var obj = new BookMyShow(n, m)\n * var param_1 = obj.gather(k,maxRow)\n * var param_2 = obj.scatter(k,maxRow)\n */"}, {"value": "php", "text": "PHP", "defaultCode": "class BookMyShow {\n    /**\n     * @param Integer $n\n     * @param Integer $m\n     */\n    function __construct($n, $m) {\n        \n    }\n  \n    /**\n     * @param Integer $k\n     * @param Integer $maxRow\n     * @return Integer[]\n     */\n    function gather($k, $maxRow) {\n        \n    }\n  \n    /**\n     * @param Integer $k\n     * @param Integer $maxRow\n     * @return Boolean\n     */\n    function scatter($k, $maxRow) {\n        \n    }\n}\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * $obj = BookMyShow($n, $m);\n * $ret_1 = $obj->gather($k, $maxRow);\n * $ret_2 = $obj->scatter($k, $maxRow);\n */"}, {"value": "swift", "text": "Swift", "defaultCode": "\nclass BookMyShow {\n\n    init(_ n: Int, _ m: Int) {\n        \n    }\n    \n    func gather(_ k: Int, _ maxRow: Int) -> [Int] {\n        \n    }\n    \n    func scatter(_ k: Int, _ maxRow: Int) -> Bool {\n        \n    }\n}\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * let obj = BookMyShow(n, m)\n * let ret_1: [Int] = obj.gather(k, maxRow)\n * let ret_2: Bool = obj.scatter(k, maxRow)\n */"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class BookMyShow(n: Int, m: Int) {\n\n    fun gather(k: Int, maxRow: Int): IntArray {\n        \n    }\n\n    fun scatter(k: Int, maxRow: Int): Boolean {\n        \n    }\n\n}\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * var obj = BookMyShow(n, m)\n * var param_1 = obj.gather(k,maxRow)\n * var param_2 = obj.scatter(k,maxRow)\n */"}, {"value": "dart", "text": "Dart", "defaultCode": "class BookMyShow {\n\n  BookMyShow(int n, int m) {\n    \n  }\n  \n  List<int> gather(int k, int maxRow) {\n    \n  }\n  \n  bool scatter(int k, int maxRow) {\n    \n  }\n}\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * BookMyShow obj = BookMyShow(n, m);\n * List<int> param1 = obj.gather(k,maxRow);\n * bool param2 = obj.scatter(k,maxRow);\n */"}, {"value": "golang", "text": "Go", "defaultCode": "type BookMyShow struct {\n    \n}\n\n\nfunc Constructor(n int, m int) BookMyShow {\n    \n}\n\n\nfunc (this *BookMyShow) Gather(k int, maxRow int) []int {\n    \n}\n\n\nfunc (this *BookMyShow) Scatter(k int, maxRow int) bool {\n    \n}\n\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * obj := Constructor(n, m);\n * param_1 := obj.Gather(k,maxRow);\n * param_2 := obj.Scatter(k,maxRow);\n */"}, {"value": "ruby", "text": "Ruby", "defaultCode": "class BookMyShow\n\n=begin\n    :type n: Integer\n    :type m: Integer\n=end\n    def initialize(n, m)\n        \n    end\n\n\n=begin\n    :type k: Integer\n    :type max_row: Integer\n    :rtype: Integer[]\n=end\n    def gather(k, max_row)\n        \n    end\n\n\n=begin\n    :type k: Integer\n    :type max_row: Integer\n    :rtype: Boolean\n=end\n    def scatter(k, max_row)\n        \n    end\n\n\nend\n\n# Your BookMyShow object will be instantiated and called as such:\n# obj = BookMyShow.new(n, m)\n# param_1 = obj.gather(k, max_row)\n# param_2 = obj.scatter(k, max_row)"}, {"value": "scala", "text": "Scala", "defaultCode": "class BookMyShow(_n: Int, _m: Int) {\n\n    def gather(k: Int, maxRow: Int): Array[Int] = {\n        \n    }\n\n    def scatter(k: Int, maxRow: Int): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * val obj = new BookMyShow(n, m)\n * val param_1 = obj.gather(k,maxRow)\n * val param_2 = obj.scatter(k,maxRow)\n */"}, {"value": "rust", "text": "Rust", "defaultCode": "struct BookMyShow {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl BookMyShow {\n\n    fn new(n: i32, m: i32) -> Self {\n        \n    }\n    \n    fn gather(&self, k: i32, max_row: i32) -> Vec<i32> {\n        \n    }\n    \n    fn scatter(&self, k: i32, max_row: i32) -> bool {\n        \n    }\n}\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * let obj = BookMyShow::new(n, m);\n * let ret_1: Vec<i32> = obj.gather(k, maxRow);\n * let ret_2: bool = obj.scatter(k, maxRow);\n */"}, {"value": "racket", "text": "Racket", "defaultCode": "(define book-my-show%\n  (class object%\n    (super-new)\n    \n    ; n : exact-integer?\n    ; m : exact-integer?\n    (init-field\n      n\n      m)\n    \n    ; gather : exact-integer? exact-integer? -> (listof exact-integer?)\n    (define/public (gather k max-row)\n      )\n    ; scatter : exact-integer? exact-integer? -> boolean?\n    (define/public (scatter k max-row)\n      )))\n\n;; Your book-my-show% object will be instantiated and called as such:\n;; (define obj (new book-my-show% [n n] [m m]))\n;; (define param_1 (send obj gather k max-row))\n;; (define param_2 (send obj scatter k max-row))"}, {"value": "erlang", "text": "Erlang", "defaultCode": "-spec book_my_show_init_(N :: integer(), M :: integer()) -> any().\nbook_my_show_init_(N, M) ->\n  .\n\n-spec book_my_show_gather(K :: integer(), MaxRow :: integer()) -> [integer()].\nbook_my_show_gather(K, MaxRow) ->\n  .\n\n-spec book_my_show_scatter(K :: integer(), MaxRow :: integer()) -> boolean().\nbook_my_show_scatter(K, MaxRow) ->\n  .\n\n\n%% Your functions will be called as such:\n%% book_my_show_init_(N, M),\n%% Param_1 = book_my_show_gather(K, MaxRow),\n%% Param_2 = book_my_show_scatter(K, MaxRow),\n\n%% book_my_show_init_ will be called before every test case, in which you can do some necessary initializations."}, {"value": "elixir", "text": "Elixir", "defaultCode": "defmodule BookMyShow do\n  @spec init_(n :: integer, m :: integer) :: any\n  def init_(n, m) do\n    \n  end\n\n  @spec gather(k :: integer, max_row :: integer) :: [integer]\n  def gather(k, max_row) do\n    \n  end\n\n  @spec scatter(k :: integer, max_row :: integer) :: boolean\n  def scatter(k, max_row) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# BookMyShow.init_(n, m)\n# param_1 = BookMyShow.gather(k, max_row)\n# param_2 = BookMyShow.scatter(k, max_row)\n\n# BookMyShow.init_ will be called before every test case, in which you can do some necessary initializations."}, {"value": "cangjie", "text": "Cangjie", "defaultCode": "class BookMyShow {\n    init(n: Int64, m: Int64) {\n\n    }\n    \n    func gather(k: Int64, maxRow: Int64): Array<Int64> {\n\n    }\n    \n    func scatter(k: Int64, maxRow: Int64): Bool {\n\n    }\n}\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * let obj: BookMyShow = BookMyShow(n, m)\n * let param_1 = obj.gather(k,maxRow)\n * let param_2 = obj.scatter(k,maxRow)\n */"}]}