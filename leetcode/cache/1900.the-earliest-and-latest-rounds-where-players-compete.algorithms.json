{"id": 1900, "fid": "1900", "name": "最佳运动员的比拼回合", "slug": "the-earliest-and-latest-rounds-where-players-compete", "link": "https://leetcode.cn/problems/the-earliest-and-latest-rounds-where-players-compete/description/", "percent": 0, "level": "Hard", "category": "algorithms", "en_name": "The Earliest and Latest Rounds Where Players Compete", "cn_name": "最佳运动员的比拼回合", "desc": "<p><code>n</code> 名运动员参与一场锦标赛，所有运动员站成一排，并根据 <strong>最开始的</strong> 站位从 <code>1</code> 到 <code>n</code> 编号（运动员 <code>1</code> 是这一排中的第一个运动员，运动员 <code>2</code> 是第二个运动员，依此类推）。</p>\n\n<p>锦标赛由多个回合组成（从回合 <code>1</code> 开始）。每一回合中，这一排从前往后数的第 <code>i</code> 名运动员需要与从后往前数的第 <code>i</code> 名运动员比拼，获胜者将会进入下一回合。如果当前回合中运动员数目为奇数，那么中间那位运动员将轮空晋级下一回合。</p>\n\n<ul>\n\t<li>例如，当前回合中，运动员 <code>1, 2, 4, 6, 7</code> 站成一排\n\n\t<ul>\n\t\t<li>运动员 <code>1</code> 需要和运动员 <code>7</code> 比拼</li>\n\t\t<li>运动员 <code>2</code> 需要和运动员 <code>6</code> 比拼</li>\n\t\t<li>运动员 <code>4</code> 轮空晋级下一回合</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>每回合结束后，获胜者将会基于最开始分配给他们的原始顺序（升序）重新排成一排。</p>\n\n<p>编号为 <code>firstPlayer</code> 和 <code>secondPlayer</code> 的运动员是本场锦标赛中的最佳运动员。在他们开始比拼之前，完全可以战胜任何其他运动员。而任意两个其他运动员进行比拼时，其中任意一个都有获胜的可能，因此你可以 <strong>裁定</strong> 谁是这一回合的获胜者。</p>\n\n<p>给你三个整数 <code>n</code>、<code>firstPlayer</code> 和 <code>secondPlayer</code> 。返回一个由两个值组成的整数数组，分别表示两位最佳运动员在本场锦标赛中比拼的 <strong>最早</strong> 回合数和 <strong>最晚</strong> 回合数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 11, firstPlayer = 2, secondPlayer = 4\n<strong>输出：</strong>[3,4]\n<strong>解释：</strong>\n一种能够产生最早回合数的情景是：\n回合 1：1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\n回合 2：2, 3, 4, 5, 6, 11\n回合 3：2, 3, 4\n一种能够产生最晚回合数的情景是：\n回合 1：1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\n回合 2：1, 2, 3, 4, 5, 6\n回合 3：1, 2, 4\n回合 4：2, 4\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 5, firstPlayer = 1, secondPlayer = 5\n<strong>输出：</strong>[1,1]\n<strong>解释：</strong>两名最佳运动员 1 和 5 将会在回合 1 进行比拼。\n不存在使他们在其他回合进行比拼的可能。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 28</code></li>\n\t<li><code>1 &lt;= firstPlayer &lt; secondPlayer &lt;= n</code></li>\n</ul>\n", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class Solution {\npublic:\n    vector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\n        \n    }\n};"}, {"value": "java", "text": "Java", "defaultCode": "class Solution {\n    public int[] earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\n        \n    }\n}"}, {"value": "python", "text": "Python", "defaultCode": "class Solution(object):\n    def earliestAndLatest(self, n, firstPlayer, secondPlayer):\n        \"\"\"\n        :type n: int\n        :type firstPlayer: int\n        :type secondPlayer: int\n        :rtype: List[int]\n        \"\"\"\n        "}, {"value": "python3", "text": "Python3", "defaultCode": "class Solution:\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\n        "}, {"value": "c", "text": "C", "defaultCode": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* earliestAndLatest(int n, int firstPlayer, int secondPlayer, int* returnSize) {\n    \n}"}, {"value": "csharp", "text": "C#", "defaultCode": "public class Solution {\n    public int[] EarliestAndLatest(int n, int firstPlayer, int secondPlayer) {\n        \n    }\n}"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * @param {number} n\n * @param {number} firstPlayer\n * @param {number} secondPlayer\n * @return {number[]}\n */\nvar earliestAndLatest = function(n, firstPlayer, secondPlayer) {\n    \n};"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "function earliestAndLatest(n: number, firstPlayer: number, secondPlayer: number): number[] {\n    \n};"}, {"value": "php", "text": "PHP", "defaultCode": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer $firstPlayer\n     * @param Integer $secondPlayer\n     * @return Integer[]\n     */\n    function earliestAndLatest($n, $firstPlayer, $secondPlayer) {\n        \n    }\n}"}, {"value": "swift", "text": "Swift", "defaultCode": "class Solution {\n    func earliestAndLatest(_ n: Int, _ firstPlayer: Int, _ secondPlayer: Int) -> [Int] {\n        \n    }\n}"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class Solution {\n    fun earliestAndLatest(n: Int, firstPlayer: Int, secondPlayer: Int): IntArray {\n        \n    }\n}"}, {"value": "dart", "text": "Dart", "defaultCode": "class Solution {\n  List<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {\n    \n  }\n}"}, {"value": "golang", "text": "Go", "defaultCode": "func earliestAndLatest(n int, firstPlayer int, secondPlayer int) []int {\n    \n}"}, {"value": "ruby", "text": "Ruby", "defaultCode": "# @param {Integer} n\n# @param {Integer} first_player\n# @param {Integer} second_player\n# @return {Integer[]}\ndef earliest_and_latest(n, first_player, second_player)\n    \nend"}, {"value": "scala", "text": "Scala", "defaultCode": "object Solution {\n    def earliestAndLatest(n: Int, firstPlayer: Int, secondPlayer: Int): Array[Int] = {\n        \n    }\n}"}, {"value": "rust", "text": "Rust", "defaultCode": "impl Solution {\n    pub fn earliest_and_latest(n: i32, first_player: i32, second_player: i32) -> Vec<i32> {\n        \n    }\n}"}, {"value": "racket", "text": "Racket", "defaultCode": "(define/contract (earliest-and-latest n firstPlayer secondPlayer)\n  (-> exact-integer? exact-integer? exact-integer? (listof exact-integer?))\n  )"}, {"value": "erlang", "text": "Erlang", "defaultCode": "-spec earliest_and_latest(N :: integer(), FirstPlayer :: integer(), SecondPlayer :: integer()) -> [integer()].\nearliest_and_latest(N, FirstPlayer, SecondPlayer) ->\n  ."}, {"value": "elixir", "text": "Elixir", "defaultCode": "defmodule Solution do\n  @spec earliest_and_latest(n :: integer, first_player :: integer, second_player :: integer) :: [integer]\n  def earliest_and_latest(n, first_player, second_player) do\n    \n  end\nend"}, {"value": "cangjie", "text": "Cangjie", "defaultCode": "class Solution {\n    func earliestAndLatest(n: Int64, firstPlayer: Int64, secondPlayer: Int64): Array<Int64> {\n\n    }\n}"}]}