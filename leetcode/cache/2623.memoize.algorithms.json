{"id": 2623, "fid": "2623", "name": "记忆函数", "slug": "memoize", "link": "https://leetcode.cn/problems/memoize/description/", "percent": 0, "level": "Medium", "category": "algorithms", "en_name": "Memoize", "cn_name": "记忆函数", "desc": "<p>请你编写一个函数 <code>fn</code>，它接收另一个函数作为输入，并返回该函数的 <strong>记忆化</strong> 后的结果。</p>\n\n<p><strong>记忆函数</strong> 是一个对于相同的输入永远不会被调用两次的函数。相反，它将返回一个缓存值。</p>\n\n<p>你可以假设有 <strong>3</strong> 个可能的输入函数：<code>sum</code> 、<code>fib</code> 和 <code>factorial</code> 。</p>\n\n<ul>\n\t<li>&nbsp;<code>sum</code> 接收两个整型参数 <code>a</code> 和 <code>b</code> ，并返回 <code>a + b</code> 。假设如果参数 <code>(b, a)</code> 已经缓存了值，其中 <code>a != b</code>，它不能用于参数 <code>(a, b)</code>。例如，如果参数是 <code>(3, 2)</code> 和 <code>(2, 3)</code>，则应进行两个单独的调用。</li>\n\t<li>&nbsp;<code>fib</code> 接收一个整型参数&nbsp;<code>n</code> ，如果 <code>n &lt;= 1</code> 则返回 <code>1</code>，否则返回 <code>fib (n - 1) + fib (n - 2)</code>。</li>\n\t<li>&nbsp;<code>factorial</code> 接收一个整型参数 <code>n</code> ，如果 <code>n &lt;= 1</code> 则返回&nbsp;&nbsp;<code>1</code>&nbsp;，否则返回 <code>factorial(n - 1) * n</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nfnName = \"sum\"\nactions = [\"call\",\"call\",\"getCallCount\",\"call\",\"getCallCount\"]\nvalues = [[2,2],[2,2],[],[1,2],[]]\n<strong>输出：</strong>[4,4,1,3,2]\n<strong>解释：</strong>\nconst sum = (a, b) =&gt; a + b;\nconst memoizedSum = memoize(sum);\nmemoizedSum (2, 2);// \"call\" - 返回 4。sum() 被调用，因为之前没有使用参数 (2, 2) 调用过。\nmemoizedSum (2, 2);// \"call\" - 返回 4。没有调用 sum()，因为前面有相同的输入。\n// \"getCallCount\" - 总调用数： 1\nmemoizedSum(1, 2);// \"call\" - 返回 3。sum() 被调用，因为之前没有使用参数 (1, 2) 调用过。\n// \"getCallCount\" - 总调用数： 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：\n</strong>fnName = \"factorial\"\nactions = [\"call\",\"call\",\"call\",\"getCallCount\",\"call\",\"getCallCount\"]\nvalues = [[2],[3],[2],[],[3],[]]\n<strong>输出：</strong>[2,6,2,2,6,2]\n<strong>解释：</strong>\nconst factorial = (n) =&gt; (n &lt;= 1) ? 1 : (n * factorial(n - 1));\nconst memoFactorial = memoize(factorial);\nmemoFactorial(2); // \"call\" - 返回 2。\nmemoFactorial(3); // \"call\" - 返回 6。\nmemoFactorial(2); // \"call\" - 返回 2。 没有调用 factorial()，因为前面有相同的输入。\n// \"getCallCount\" -  总调用数：2\nmemoFactorial(3); // \"call\" - 返回 6。 没有调用 factorial()，因为前面有相同的输入。\n// \"getCallCount\" -  总调用数：2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：\n</strong>fnName = \"fib\"\nactions = [\"call\",\"getCallCount\"]\nvalues = [[5],[]]\n<strong>输出：</strong>[8,1]\n<strong>解释：\n</strong>fib(5) = 8 // \"call\"\n// \"getCallCount\" -&nbsp;总调用数：1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= a, b &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= n &lt;= 10</code></li>\n\t<li><code>1 &lt;= actions.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>actions.length === values.length</code></li>\n\t<li><code>actions[i]</code> 为&nbsp;\"call\" 和 \"getCallCount\" 中的一个</li>\n\t<li><code>fnName</code> 为 \"sum\", \"factorial\" 和 \"fib\" 中的一个</li>\n</ul>\n", "templates": [{"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * @param {Function} fn\n * @return {Function}\n */\nfunction memoize(fn) {\n    \n    return function(...args) {\n        \n    }\n}\n\n\n/** \n * let callCount = 0;\n * const memoizedFn = memoize(function (a, b) {\n *\t callCount += 1;\n *   return a + b;\n * })\n * memoizedFn(2, 3) // 5\n * memoizedFn(2, 3) // 5\n * console.log(callCount) // 1 \n */"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "type Fn = (...params: number[]) => number\n\nfunction memoize(fn: Fn): Fn {\n    \n    return function(...args) {\n        \n    }\n}\n\n\n/** \n * let callCount = 0;\n * const memoizedFn = memoize(function (a, b) {\n *\t callCount += 1;\n *   return a + b;\n * })\n * memoizedFn(2, 3) // 5\n * memoizedFn(2, 3) // 5\n * console.log(callCount) // 1 \n */"}]}