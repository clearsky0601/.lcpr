{"id": "LCP 45", "fid": "LCP 45", "name": "自行车炫技赛场", "slug": "kplEvH", "link": "https://leetcode.cn/problems/kplEvH/description/", "percent": 0, "level": "Medium", "category": "algorithms", "en_name": "自行车炫技赛场", "cn_name": "自行车炫技赛场", "desc": "「力扣挑战赛」中 `N*M` 大小的自行车炫技赛场的场地由一片连绵起伏的上下坡组成，场地的高度值记录于二维数组 `terrain` 中，场地的减速值记录于二维数组 `obstacle` 中。\n- 若选手骑着自行车从高度为 `h1` 且减速值为 `o1` 的位置到高度为 `h2` 且减速值为 `o2` 的相邻位置（上下左右四个方向），速度变化值为 `h1-h2-o2`（负值减速，正值增速）。\n\n选手初始位于坐标 `position` 处且初始速度为 1，请问选手可以刚好到其他哪些位置时速度依旧为 1。请以二维数组形式返回这些位置。若有多个位置则按行坐标升序排列，若有多个位置行坐标相同则按列坐标升序排列。\n\n**注意：** 骑行过程中速度不能为零或负值\n\n**示例 1：**\n> 输入\b：`position = [0,0], terrain = [[0,0],[0,0]], obstacle = [[0,0],[0,0]]`\n> \n> 输出：`[[0,1],[1,0],[1,1]]`\n> \n> 解释：\n> 由于当前场地属于平地，根据上面的规则，选手从`[0,0]`的位置出发都能刚好在其他处的位置速度为 1。\n\n**示例 2：**\n> 输入\b：`position = [1,1], terrain = [[5,0],[0,6]], obstacle = [[0,6],[7,0]]`\n> \n> 输出：`[[0,1]]`\n> \n> 解释：\n> 选手从 `[1,1]` 处的位置出发，到 `[0,1]` 处的位置时恰好速度为 1。\n\n\n**提示：**\n- `n == terrain.length == obstacle.length`\n- `m == terrain[i].length == obstacle[i].length`\n- `1 <= n <= 100`\n- `1 <= m <= 100`\n- `0 <= terrain[i][j], obstacle[i][j] <= 100`\n- `position.length == 2`\n- `0 <= position[0] < n`\n- `0 <= position[1] < m`", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class Solution {\npublic:\n    vector<vector<int>> bicycleYard(vector<int>& position, vector<vector<int>>& terrain, vector<vector<int>>& obstacle) {\n\n    }\n};"}, {"value": "java", "text": "Java", "defaultCode": "class Solution {\n    public int[][] bicycleYard(int[] position, int[][] terrain, int[][] obstacle) {\n\n    }\n}"}, {"value": "python", "text": "Python", "defaultCode": "class Solution(object):\n    def bicycleYard(self, position, terrain, obstacle):\n        \"\"\"\n        :type position: List[int]\n        :type terrain: List[List[int]]\n        :type obstacle: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\""}, {"value": "python3", "text": "Python3", "defaultCode": "class Solution:\n    def bicycleYard(self, position: List[int], terrain: List[List[int]], obstacle: List[List[int]]) -> List[List[int]]:"}, {"value": "c", "text": "C", "defaultCode": "\n\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** bicycleYard(int* position, int positionSize, int** terrain, int terrainSize, int* terrainColSize, int** obstacle, int obstacleSize, int* obstacleColSize, int* returnSize, int** returnColumnSizes){\n\n}"}, {"value": "csharp", "text": "C#", "defaultCode": "public class Solution {\n    public int[][] BicycleYard(int[] position, int[][] terrain, int[][] obstacle) {\n\n    }\n}"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * @param {number[]} position\n * @param {number[][]} terrain\n * @param {number[][]} obstacle\n * @return {number[][]}\n */\nvar bicycleYard = function(position, terrain, obstacle) {\n\n};"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "function bicycleYard(position: number[], terrain: number[][], obstacle: number[][]): number[][] {\n\n};"}, {"value": "php", "text": "PHP", "defaultCode": "class Solution {\n\n    /**\n     * @param Integer[] $position\n     * @param Integer[][] $terrain\n     * @param Integer[][] $obstacle\n     * @return Integer[][]\n     */\n    function bicycleYard($position, $terrain, $obstacle) {\n\n    }\n}"}, {"value": "swift", "text": "Swift", "defaultCode": "class Solution {\n    func bicycleYard(_ position: [Int], _ terrain: [[Int]], _ obstacle: [[Int]]) -> [[Int]] {\n\n    }\n}"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class Solution {\n    fun bicycleYard(position: IntArray, terrain: Array<IntArray>, obstacle: Array<IntArray>): Array<IntArray> {\n\n    }\n}"}, {"value": "golang", "text": "Go", "defaultCode": "func bicycleYard(position []int, terrain [][]int, obstacle [][]int) [][]int {\n\n}"}, {"value": "ruby", "text": "Ruby", "defaultCode": "# @param {Integer[]} position\n# @param {Integer[][]} terrain\n# @param {Integer[][]} obstacle\n# @return {Integer[][]}\ndef bicycle_yard(position, terrain, obstacle)\n\nend"}, {"value": "scala", "text": "Scala", "defaultCode": "object Solution {\n    def bicycleYard(position: Array[Int], terrain: Array[Array[Int]], obstacle: Array[Array[Int]]): Array[Array[Int]] = {\n\n    }\n}"}, {"value": "rust", "text": "Rust", "defaultCode": "impl Solution {\n    pub fn bicycle_yard(position: Vec<i32>, terrain: Vec<Vec<i32>>, obstacle: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n\n    }\n}"}, {"value": "racket", "text": "Racket", "defaultCode": "(define/contract (bicycle-yard position terrain obstacle)\n  (-> (listof exact-integer?) (listof (listof exact-integer?)) (listof (listof exact-integer?)) (listof (listof exact-integer?)))\n\n  )"}]}