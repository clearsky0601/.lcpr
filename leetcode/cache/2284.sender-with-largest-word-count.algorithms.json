{"id": 2284, "fid": "2284", "name": "最多单词数的发件人", "slug": "sender-with-largest-word-count", "link": "https://leetcode.cn/problems/sender-with-largest-word-count/description/", "percent": 0, "level": "Medium", "category": "algorithms", "en_name": "Sender With Largest Word Count", "cn_name": "最多单词数的发件人", "desc": "<p>给你一个聊天记录，共包含 <code>n</code>&nbsp;条信息。给你两个字符串数组&nbsp;<code>messages</code> 和&nbsp;<code>senders</code>&nbsp;，其中&nbsp;<code>messages[i]</code>&nbsp;是&nbsp;<code>senders[i]</code>&nbsp;发出的一条&nbsp;<strong>信息</strong>&nbsp;。</p>\n\n<p>一条 <strong>信息</strong>&nbsp;是若干用单个空格连接的 <strong>单词</strong>&nbsp;，信息开头和结尾不会有多余空格。发件人的 <strong>单词计数</strong>&nbsp;是这个发件人总共发出的 <strong>单词数</strong>&nbsp;。注意，一个发件人可能会发出多于一条信息。</p>\n\n<p>请你返回发出单词数 <strong>最多</strong>&nbsp;的发件人名字。如果有多个发件人发出最多单词数，请你返回 <strong>字典序</strong>&nbsp;最大的名字。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>字典序里，大写字母小于小写字母。</li>\n\t<li><code>\"Alice\"</code> 和&nbsp;<code>\"alice\"</code>&nbsp;是不同的名字。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>messages = [\"Hello userTwooo\",\"Hi userThree\",\"Wonderful day Alice\",\"Nice day userThree\"], senders = [\"Alice\",\"userTwo\",\"userThree\",\"Alice\"]\n<b>输出：</b>\"Alice\"\n<b>解释：</b>Alice 总共发出了 2 + 3 = 5 个单词。\nuserTwo 发出了 2 个单词。\nuserThree 发出了 3 个单词。\n由于 Alice 发出单词数最多，所以我们返回 \"Alice\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>messages = [\"How is leetcode for everyone\",\"Leetcode is useful for practice\"], senders = [\"Bob\",\"Charlie\"]\n<b>输出：</b>\"Charlie\"\n<b>解释：</b>Bob 总共发出了 5 个单词。\nCharlie 总共发出了 5 个单词。\n由于最多单词数打平，返回字典序最大的名字，也就是 Charlie 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == messages.length == senders.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= messages[i].length &lt;= 100</code></li>\n\t<li><code>1 &lt;= senders[i].length &lt;= 10</code></li>\n\t<li><code>messages[i]</code>&nbsp;包含大写字母、小写字母和&nbsp;<code>' '</code>&nbsp;。</li>\n\t<li><code>messages[i]</code>&nbsp;中所有单词都由 <strong>单个空格</strong>&nbsp;隔开。</li>\n\t<li><code>messages[i]</code>&nbsp;不包含前导和后缀空格。</li>\n\t<li><code>senders[i]</code>&nbsp;只包含大写英文字母和小写英文字母。</li>\n</ul>\n", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class Solution {\npublic:\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\n        \n    }\n};"}, {"value": "java", "text": "Java", "defaultCode": "class Solution {\n    public String largestWordCount(String[] messages, String[] senders) {\n        \n    }\n}"}, {"value": "python", "text": "Python", "defaultCode": "class Solution(object):\n    def largestWordCount(self, messages, senders):\n        \"\"\"\n        :type messages: List[str]\n        :type senders: List[str]\n        :rtype: str\n        \"\"\"\n        "}, {"value": "python3", "text": "Python3", "defaultCode": "class Solution:\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\n        "}, {"value": "c", "text": "C", "defaultCode": "char* largestWordCount(char** messages, int messagesSize, char** senders, int sendersSize) {\n    \n}"}, {"value": "csharp", "text": "C#", "defaultCode": "public class Solution {\n    public string LargestWordCount(string[] messages, string[] senders) {\n        \n    }\n}"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * @param {string[]} messages\n * @param {string[]} senders\n * @return {string}\n */\nvar largestWordCount = function(messages, senders) {\n    \n};"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "function largestWordCount(messages: string[], senders: string[]): string {\n    \n};"}, {"value": "php", "text": "PHP", "defaultCode": "class Solution {\n\n    /**\n     * @param String[] $messages\n     * @param String[] $senders\n     * @return String\n     */\n    function largestWordCount($messages, $senders) {\n        \n    }\n}"}, {"value": "swift", "text": "Swift", "defaultCode": "class Solution {\n    func largestWordCount(_ messages: [String], _ senders: [String]) -> String {\n        \n    }\n}"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class Solution {\n    fun largestWordCount(messages: Array<String>, senders: Array<String>): String {\n        \n    }\n}"}, {"value": "dart", "text": "Dart", "defaultCode": "class Solution {\n  String largestWordCount(List<String> messages, List<String> senders) {\n    \n  }\n}"}, {"value": "golang", "text": "Go", "defaultCode": "func largestWordCount(messages []string, senders []string) string {\n    \n}"}, {"value": "ruby", "text": "Ruby", "defaultCode": "# @param {String[]} messages\n# @param {String[]} senders\n# @return {String}\ndef largest_word_count(messages, senders)\n    \nend"}, {"value": "scala", "text": "Scala", "defaultCode": "object Solution {\n    def largestWordCount(messages: Array[String], senders: Array[String]): String = {\n        \n    }\n}"}, {"value": "rust", "text": "Rust", "defaultCode": "impl Solution {\n    pub fn largest_word_count(messages: Vec<String>, senders: Vec<String>) -> String {\n        \n    }\n}"}, {"value": "racket", "text": "Racket", "defaultCode": "(define/contract (largest-word-count messages senders)\n  (-> (listof string?) (listof string?) string?)\n  )"}, {"value": "erlang", "text": "Erlang", "defaultCode": "-spec largest_word_count(Messages :: [unicode:unicode_binary()], Senders :: [unicode:unicode_binary()]) -> unicode:unicode_binary().\nlargest_word_count(Messages, Senders) ->\n  ."}, {"value": "elixir", "text": "Elixir", "defaultCode": "defmodule Solution do\n  @spec largest_word_count(messages :: [String.t], senders :: [String.t]) :: String.t\n  def largest_word_count(messages, senders) do\n    \n  end\nend"}, {"value": "cangjie", "text": "Cangjie", "defaultCode": "class Solution {\n    func largestWordCount(messages: Array<String>, senders: Array<String>): String {\n\n    }\n}"}]}