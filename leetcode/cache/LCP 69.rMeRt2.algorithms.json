{"id": "LCP 69", "fid": "LCP 69", "name": "Hello LeetCode!", "slug": "rMeRt2", "link": "https://leetcode.cn/problems/rMeRt2/description/", "percent": 0, "level": "Hard", "category": "algorithms", "en_name": "Hello LeetCode!", "cn_name": "Hello LeetCode!", "desc": "力扣嘉年华同样准备了纪念品展位，参观者只需要集齐 `helloleetcode` 的 `13` 张字母卡片即可获得力扣纪念章。\n\n在展位上有一些由字母卡片拼成的单词，`words[i][j]` 表示第 `i` 个单词的第 `j` 个字母。\n\n你可以从这些单词中取出一些卡片，但每次拿取卡片都需要消耗游戏代币，规则如下：\n\n- 从一个单词中取一个字母所需要的代币数量，为该字母左边和右边字母数量之积\n\n- 可以从一个单词中多次取字母，每个字母仅可被取一次\n\n> 例如：从 `example` 中取出字母 `a`，需要消耗代币 `2*4=8`，字母取出后单词变为 `exmple`；\n再从中取出字母 `m`，需要消耗代币 `2*3=6`，字母取出后单词变为 `exple`；\n\n请返回取得 `helloleetcode` 这些字母需要消耗代币的 **最少** 数量。如果无法取得，返回 `-1`。\n\n**注意：**\n- 取出字母的顺序没有要求\n- 取出的所有字母恰好可以拼成 `helloleetcode` \n\n**示例 1：**\n>输入：`words = [\"hold\",\"engineer\",\"cost\",\"level\"]`\n>\n>输出：`5`\n>\n>解释：最优方法为：\n>从 `hold` 依次取出 `h`、`o`、`l`、`d`， 代价均为 `0`\n>从 `engineer` 依次取出第 `1` 个 `e` 与最后一个 `e`， 代价为 `0` 和 `5*1=5`\n>从 `cost` 取出 `c`、`o`、`t`， 代价均为 `0`\n>从 `level` 依次取出 `l`、`l`、`e`、`e`， 代价均为 `0`\n>所有字母恰好可以拼成 `helloleetcode`，因此最小的代价为 `5`\n\n**示例 2：**\n>输入：`words = [\"hello\",\"leetcode\"]`\n>\n>输出：`0`\n\n**提示：**\n+ `n == words.length`\n+ `m == words[i].length`\n+ `1 <= n <= 24`\n+ `1 <= m <= 8`\n+ `words[i][j]` 仅为小写字母", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class Solution {\npublic:\n    int Leetcode(vector<string>& words) {\n\n    }\n};"}, {"value": "java", "text": "Java", "defaultCode": "class Solution {\n    public int Leetcode(String[] words) {\n\n    }\n}"}, {"value": "python", "text": "Python", "defaultCode": "class Solution(object):\n    def Leetcode(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\""}, {"value": "python3", "text": "Python3", "defaultCode": "class Solution:\n    def Leetcode(self, words: List[str]) -> int:"}, {"value": "c", "text": "C", "defaultCode": "\n\nint Leetcode(char** words, int wordsSize){\n\n}"}, {"value": "csharp", "text": "C#", "defaultCode": "public class Solution {\n    public int Leetcode(string[] words) {\n\n    }\n}"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * @param {string[]} words\n * @return {number}\n */\nvar Leetcode = function(words) {\n\n};"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "function Leetcode(words: string[]): number {\n\n};"}, {"value": "php", "text": "PHP", "defaultCode": "class Solution {\n\n    /**\n     * @param String[] $words\n     * @return Integer\n     */\n    function Leetcode($words) {\n\n    }\n}"}, {"value": "swift", "text": "Swift", "defaultCode": "class Solution {\n    func Leetcode(_ words: [String]) -> Int {\n\n    }\n}"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class Solution {\n    fun Leetcode(words: Array<String>): Int {\n\n    }\n}"}, {"value": "golang", "text": "Go", "defaultCode": "func Leetcode(words []string) int {\n\n}"}, {"value": "ruby", "text": "Ruby", "defaultCode": "# @param {String[]} words\n# @return {Integer}\ndef leetcode(words)\n\nend"}, {"value": "scala", "text": "Scala", "defaultCode": "object Solution {\n    def Leetcode(words: Array[String]): Int = {\n\n    }\n}"}, {"value": "rust", "text": "Rust", "defaultCode": "impl Solution {\n    pub fn leetcode(words: Vec<String>) -> i32 {\n\n    }\n}"}, {"value": "racket", "text": "Racket", "defaultCode": "(define/contract (leetcode words)\n  (-> (listof string?) exact-integer?)\n\n  )"}, {"value": "erlang", "text": "Erlang", "defaultCode": "-spec leetcode(Words :: [unicode:unicode_binary()]) -> integer().\nleetcode(Words) ->\n  ."}, {"value": "elixir", "text": "Elixir", "defaultCode": "defmodule Solution do\n  @spec leetcode(words :: [String.t]) :: integer\n  def leetcode(words) do\n\n  end\nend"}]}