{"id": "LCP 13", "fid": "LCP 13", "name": "寻宝", "slug": "xun-bao", "link": "https://leetcode.cn/problems/xun-bao/description/", "percent": 0, "level": "Hard", "category": "algorithms", "en_name": "寻宝", "cn_name": "寻宝", "desc": "<p>我们得到了一副藏宝图，藏宝图显示，在一个迷宫中存在着未被世人发现的宝藏。</p>\n\n<p>迷宫是一个二维矩阵，用一个字符串数组表示。它标识了唯一的入口（用 &#39;S&#39; 表示），和唯一的宝藏地点（用 &#39;T&#39; 表示）。但是，宝藏被一些隐蔽的机关保护了起来。在地图上有若干个机关点（用 &#39;M&#39; 表示），<strong>只有所有机关均被触发，才可以拿到宝藏。</strong></p>\n\n<p>要保持机关的触发，需要把一个重石放在上面。迷宫中有若干个石堆（用 &#39;O&#39; 表示），每个石堆都有<strong>无限</strong>个足够触发机关的重石。但是由于石头太重，我们一次只能搬<strong>一个</strong>石头到指定地点。</p>\n\n<p>迷宫中同样有一些墙壁（用 &#39;#&#39; 表示），我们不能走入墙壁。剩余的都是可随意通行的点（用 &#39;.&#39; 表示）。石堆、机关、起点和终点（无论是否能拿到宝藏）也是可以通行的。</p>\n\n<p>我们每步可以选择向上/向下/向左/向右移动一格，并且不能移出迷宫。搬起石头和放下石头不算步数。那么，从起点开始，我们最少需要多少步才能最后拿到宝藏呢？如果无法拿到宝藏，返回 -1 。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<blockquote>\n<p>输入： [&quot;S#O&quot;, &quot;M..&quot;, &quot;M.T&quot;]</p>\n\n<p>输出：16</p>\n\n<p>解释：最优路线为： S-&gt;O, cost = 4, 去搬石头 O-&gt;第二行的M, cost = 3, M机关触发 第二行的M-&gt;O, cost = 3, 我们需要继续回去 O 搬石头。 O-&gt;第三行的M, cost = 4, 此时所有机关均触发 第三行的M-&gt;T, cost = 2，去T点拿宝藏。 总步数为16。 <img alt=\"图片.gif\" src=\"https://pic.leetcode-cn.com/6bfff669ad65d494cdc237bcedfec10a2b1ac2f2593c2bf97e9aecb41dc8a08b-%E5%9B%BE%E7%89%87.gif\" /></p>\n</blockquote>\n\n<p><strong>示例 2：</strong></p>\n\n<blockquote>\n<p>输入： [&quot;S#O&quot;, &quot;M.#&quot;, &quot;M.T&quot;]</p>\n\n<p>输出：-1</p>\n\n<p>解释：我们无法搬到石头触发机关</p>\n</blockquote>\n\n<p><strong>示例 3：</strong></p>\n\n<blockquote>\n<p>输入： [&quot;S#O&quot;, &quot;M.T&quot;, &quot;M..&quot;]</p>\n\n<p>输出：17</p>\n\n<p>解释：注意终点也是可以通行的。</p>\n</blockquote>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= maze.length&nbsp;&lt;= 100</code></li>\n\t<li><code>1 &lt;= maze[i].length&nbsp;&lt;= 100</code></li>\n\t<li><code>maze[i].length == maze[j].length</code></li>\n\t<li>S 和 T 有且只有一个</li>\n\t<li>0 &lt;= M的数量 &lt;= 16</li>\n\t<li>0 &lt;= O的数量 &lt;= 40，题目保证当迷宫中存在 M 时，一定存在至少一个 O 。</li>\n</ul>\n", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class Solution {\npublic:\n    int minimalSteps(vector<string>& maze) {\n        \n    }\n};"}, {"value": "java", "text": "Java", "defaultCode": "class Solution {\n    public int minimalSteps(String[] maze) {\n        \n    }\n}"}, {"value": "python", "text": "Python", "defaultCode": "class Solution(object):\n    def minimalSteps(self, maze):\n        \"\"\"\n        :type maze: List[str]\n        :rtype: int\n        \"\"\"\n        "}, {"value": "python3", "text": "Python3", "defaultCode": "class Solution:\n    def minimalSteps(self, maze: List[str]) -> int:\n        "}, {"value": "c", "text": "C", "defaultCode": "int minimalSteps(char** maze, int mazeSize) {\n    \n}"}, {"value": "csharp", "text": "C#", "defaultCode": "public class Solution {\n    public int MinimalSteps(string[] maze) {\n        \n    }\n}"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * @param {string[]} maze\n * @return {number}\n */\nvar minimalSteps = function(maze) {\n    \n};"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "function minimalSteps(maze: string[]): number {\n    \n};"}, {"value": "php", "text": "PHP", "defaultCode": "class Solution {\n\n    /**\n     * @param String[] $maze\n     * @return Integer\n     */\n    function minimalSteps($maze) {\n        \n    }\n}"}, {"value": "swift", "text": "Swift", "defaultCode": "class Solution {\n    func minimalSteps(_ maze: [String]) -> Int {\n        \n    }\n}"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class Solution {\n    fun minimalSteps(maze: Array<String>): Int {\n        \n    }\n}"}, {"value": "dart", "text": "Dart", "defaultCode": "class Solution {\n  int minimalSteps(List<String> maze) {\n    \n  }\n}"}, {"value": "golang", "text": "Go", "defaultCode": "func minimalSteps(maze []string) int {\n    \n}"}, {"value": "ruby", "text": "Ruby", "defaultCode": "# @param {String[]} maze\n# @return {Integer}\ndef minimal_steps(maze)\n    \nend"}, {"value": "scala", "text": "Scala", "defaultCode": "object Solution {\n    def minimalSteps(maze: Array[String]): Int = {\n        \n    }\n}"}, {"value": "rust", "text": "Rust", "defaultCode": "impl Solution {\n    pub fn minimal_steps(maze: Vec<String>) -> i32 {\n        \n    }\n}"}, {"value": "racket", "text": "Racket", "defaultCode": "(define/contract (minimal-steps maze)\n  (-> (listof string?) exact-integer?)\n  )"}, {"value": "erlang", "text": "Erlang", "defaultCode": "-spec minimal_steps(Maze :: [unicode:unicode_binary()]) -> integer().\nminimal_steps(Maze) ->\n  ."}, {"value": "elixir", "text": "Elixir", "defaultCode": "defmodule Solution do\n  @spec minimal_steps(maze :: [String.t]) :: integer\n  def minimal_steps(maze) do\n    \n  end\nend"}]}