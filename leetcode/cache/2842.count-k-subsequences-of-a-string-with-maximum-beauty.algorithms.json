{"id": 2842, "fid": "2842", "name": "统计一个字符串的 k 子序列美丽值最大的数目", "slug": "count-k-subsequences-of-a-string-with-maximum-beauty", "link": "https://leetcode.cn/problems/count-k-subsequences-of-a-string-with-maximum-beauty/description/", "percent": 0, "level": "Hard", "category": "algorithms", "en_name": "Count K-Subsequences of a String With Maximum Beauty", "cn_name": "统计一个字符串的 k 子序列美丽值最大的数目", "desc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p><strong>k 子序列</strong>指的是 <code>s</code>&nbsp;的一个长度为 <code>k</code>&nbsp;的 <strong>子序列</strong>&nbsp;，且所有字符都是 <strong>唯一</strong>&nbsp;的，也就是说每个字符在子序列里只出现过一次。</p>\n\n<p>定义&nbsp;<code>f(c)</code>&nbsp;为字符 <code>c</code>&nbsp;在 <code>s</code>&nbsp;中出现的次数。</p>\n\n<p>k 子序列的 <strong>美丽值</strong>&nbsp;定义为这个子序列中每一个字符 <code>c</code>&nbsp;的&nbsp;<code>f(c)</code>&nbsp;之 <strong>和</strong>&nbsp;。</p>\n\n<p>比方说，<code>s = \"abbbdd\"</code>&nbsp;和&nbsp;<code>k = 2</code>&nbsp;，我们有：</p>\n\n<ul>\n\t<li><code>f('a') = 1</code>, <code>f('b') = 3</code>, <code>f('d') = 2</code></li>\n\t<li><code>s</code>&nbsp;的部分 k 子序列为：\n\t<ul>\n\t\t<li><code>\"<em><strong>ab</strong></em>bbdd\"</code> -&gt; <code>\"ab\"</code>&nbsp;，美丽值为&nbsp;<code>f('a') + f('b') = 4</code></li>\n\t\t<li><code>\"<em><strong>a</strong></em>bbb<em><strong>d</strong></em>d\"</code> -&gt; <code>\"ad\"</code>&nbsp;，美丽值为&nbsp;<code>f('a') + f('d') = 3</code></li>\n\t\t<li><code>\"a<em><strong>b</strong></em>bb<em><strong>d</strong></em>d\"</code> -&gt; <code>\"bd\"</code>&nbsp;，美丽值为&nbsp;<code>f('b') + f('d') = 5</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请你返回一个整数，表示所有 <strong>k 子序列&nbsp;</strong>里面 <strong>美丽值 </strong>是&nbsp;<strong>最大值</strong>&nbsp;的子序列数目。由于答案可能很大，将结果对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;取余后返回。</p>\n\n<p>一个字符串的子序列指的是从原字符串里面删除一些字符（也可能一个字符也不删除），不改变剩下字符顺序连接得到的新字符串。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li><code>f(c)</code> 指的是字符&nbsp;<code>c</code>&nbsp;在字符串&nbsp;<code>s</code>&nbsp;的出现次数，不是在 k 子序列里的出现次数。</li>\n\t<li>两个 k 子序列如果有任何一个字符在原字符串中的下标不同，则它们是两个不同的子序列。所以两个不同的 k 子序列可能产生相同的字符串。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"bcca\", k = 2\n<b>输出：</b>4\n<b>解释：</b><span style=\"white-space: normal\">s 中我们有 f('a') = 1 ，f('b') = 1 和 f('c') = 2 。</span>\ns 的 k 子序列为：\n<em><strong>bc</strong></em>ca ，美丽值为 f('b') + f('c') = 3\n<em><strong>b</strong></em>c<em><strong>c</strong></em>a ，美丽值为 f('b') + f('c') = 3\n<em><strong>b</strong></em>cc<em><strong>a</strong></em> ，美丽值为 f('b') + f('a') = 2\nb<em><strong>c</strong></em>c<em><strong>a</strong></em><strong> </strong>，美丽值为 f('c') + f('a') = 3\nbc<em><strong>ca</strong></em> ，美丽值为 f('c') + f('a') = 3\n总共有 4 个 k 子序列美丽值为最大值 3 。\n所以答案为 4 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"abbcd\", k = 4\n<b>输出：</b>2\n<b>解释：</b><span style=\"white-space: normal\">s 中我们有 f('a') = 1 ，f('b') = 2&nbsp;，f('c') = 1&nbsp;和</span> f('d') = 1 。\ns 的 k 子序列为：\n<em><strong>ab</strong></em>b<em><strong>cd</strong></em> ，美丽值为 f('a') + f('b') + f('c') + f('d') = 5\n<span style=\"white-space: normal;\"><b><i>a</i></b></span>b<em><strong>bcd</strong></em> ，美丽值为 f('a') + f('b') + f('c') + f('d') = 5 \n总共有 2 个 k 子序列美丽值为最大值 5 。\n所以答案为 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= s.length</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class Solution {\npublic:\n    int countKSubsequencesWithMaxBeauty(string s, int k) {\n        \n    }\n};"}, {"value": "java", "text": "Java", "defaultCode": "class Solution {\n    public int countKSubsequencesWithMaxBeauty(String s, int k) {\n        \n    }\n}"}, {"value": "python", "text": "Python", "defaultCode": "class Solution(object):\n    def countKSubsequencesWithMaxBeauty(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        "}, {"value": "python3", "text": "Python3", "defaultCode": "class Solution:\n    def countKSubsequencesWithMaxBeauty(self, s: str, k: int) -> int:\n        "}, {"value": "c", "text": "C", "defaultCode": "int countKSubsequencesWithMaxBeauty(char* s, int k) {\n    \n}"}, {"value": "csharp", "text": "C#", "defaultCode": "public class Solution {\n    public int CountKSubsequencesWithMaxBeauty(string s, int k) {\n        \n    }\n}"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nvar countKSubsequencesWithMaxBeauty = function(s, k) {\n    \n};"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "function countKSubsequencesWithMaxBeauty(s: string, k: number): number {\n    \n};"}, {"value": "php", "text": "PHP", "defaultCode": "class Solution {\n\n    /**\n     * @param String $s\n     * @param Integer $k\n     * @return Integer\n     */\n    function countKSubsequencesWithMaxBeauty($s, $k) {\n        \n    }\n}"}, {"value": "swift", "text": "Swift", "defaultCode": "class Solution {\n    func countKSubsequencesWithMaxBeauty(_ s: String, _ k: Int) -> Int {\n        \n    }\n}"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class Solution {\n    fun countKSubsequencesWithMaxBeauty(s: String, k: Int): Int {\n        \n    }\n}"}, {"value": "dart", "text": "Dart", "defaultCode": "class Solution {\n  int countKSubsequencesWithMaxBeauty(String s, int k) {\n    \n  }\n}"}, {"value": "golang", "text": "Go", "defaultCode": "func countKSubsequencesWithMaxBeauty(s string, k int) int {\n    \n}"}, {"value": "ruby", "text": "Ruby", "defaultCode": "# @param {String} s\n# @param {Integer} k\n# @return {Integer}\ndef count_k_subsequences_with_max_beauty(s, k)\n    \nend"}, {"value": "scala", "text": "Scala", "defaultCode": "object Solution {\n    def countKSubsequencesWithMaxBeauty(s: String, k: Int): Int = {\n        \n    }\n}"}, {"value": "rust", "text": "Rust", "defaultCode": "impl Solution {\n    pub fn count_k_subsequences_with_max_beauty(s: String, k: i32) -> i32 {\n        \n    }\n}"}, {"value": "racket", "text": "Racket", "defaultCode": "(define/contract (count-k-subsequences-with-max-beauty s k)\n  (-> string? exact-integer? exact-integer?)\n  )"}, {"value": "erlang", "text": "Erlang", "defaultCode": "-spec count_k_subsequences_with_max_beauty(S :: unicode:unicode_binary(), K :: integer()) -> integer().\ncount_k_subsequences_with_max_beauty(S, K) ->\n  ."}, {"value": "elixir", "text": "Elixir", "defaultCode": "defmodule Solution do\n  @spec count_k_subsequences_with_max_beauty(s :: String.t, k :: integer) :: integer\n  def count_k_subsequences_with_max_beauty(s, k) do\n    \n  end\nend"}, {"value": "cangjie", "text": "Cangjie", "defaultCode": "class Solution {\n    func countKSubsequencesWithMaxBeauty(s: String, k: Int64): Int64 {\n\n    }\n}"}]}