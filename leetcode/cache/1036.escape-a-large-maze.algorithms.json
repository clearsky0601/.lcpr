{"id": 1036, "fid": "1036", "name": "逃离大迷宫", "slug": "escape-a-large-maze", "link": "https://leetcode.cn/problems/escape-a-large-maze/description/", "percent": 0, "level": "Hard", "category": "algorithms", "en_name": "Escape a Large Maze", "cn_name": "逃离大迷宫", "desc": "<p>在一个 10<sup>6</sup> x 10<sup>6</sup> 的网格中，每个网格上方格的坐标为 <code>(x, y)</code> 。</p>\n\n<p>现在从源方格 <code>source = [s<sub>x</sub>, s<sub>y</sub>]</code> 开始出发，意图赶往目标方格 <code>target = [t<sub>x</sub>, t<sub>y</sub>]</code> 。数组 <code>blocked</code> 是封锁的方格列表，其中每个 <code>blocked[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示坐标为 <code>(x<sub>i</sub>, y<sub>i</sub>)</code> 的方格是禁止通行的。</p>\n\n<p>每次移动，都可以走到网格中在四个方向上相邻的方格，只要该方格 <strong>不</strong> 在给出的封锁列表 <code>blocked</code> 上。同时，不允许走出网格。</p>\n\n<p>只有在可以通过一系列的移动从源方格 <code>source</code> 到达目标方格 <code>target</code> 时才返回 <code>true</code>。否则，返回 <code>false</code>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>blocked = [[0,1],[1,0]], source = [0,0], target = [0,2]\n<strong>输出：</strong>false\n<strong>解释：</strong>\n从源方格无法到达目标方格，因为我们无法在网格中移动。\n无法向北或者向东移动是因为方格禁止通行。\n无法向南或者向西移动是因为不能走出网格。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>blocked = [], source = [0,0], target = [999999,999999]\n<strong>输出：</strong>true\n<strong>解释：</strong>\n因为没有方格被封锁，所以一定可以到达目标方格。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= blocked.length <= 200</code></li>\n\t<li><code>blocked[i].length == 2</code></li>\n\t<li><code>0 <= x<sub>i</sub>, y<sub>i</sub> < 10<sup>6</sup></code></li>\n\t<li><code>source.length == target.length == 2</code></li>\n\t<li><code>0 <= s<sub>x</sub>, s<sub>y</sub>, t<sub>x</sub>, t<sub>y</sub> < 10<sup>6</sup></code></li>\n\t<li><code>source != target</code></li>\n\t<li>题目数据保证 <code>source</code> 和 <code>target</code> 不在封锁列表内</li>\n</ul>\n", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class Solution {\npublic:\n    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {\n        \n    }\n};"}, {"value": "java", "text": "Java", "defaultCode": "class Solution {\n    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\n        \n    }\n}"}, {"value": "python", "text": "Python", "defaultCode": "class Solution(object):\n    def isEscapePossible(self, blocked, source, target):\n        \"\"\"\n        :type blocked: List[List[int]]\n        :type source: List[int]\n        :type target: List[int]\n        :rtype: bool\n        \"\"\"\n        "}, {"value": "python3", "text": "Python3", "defaultCode": "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        "}, {"value": "c", "text": "C", "defaultCode": "bool isEscapePossible(int** blocked, int blockedSize, int* blockedColSize, int* source, int sourceSize, int* target, int targetSize) {\n    \n}"}, {"value": "csharp", "text": "C#", "defaultCode": "public class Solution {\n    public bool IsEscapePossible(int[][] blocked, int[] source, int[] target) {\n        \n    }\n}"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * @param {number[][]} blocked\n * @param {number[]} source\n * @param {number[]} target\n * @return {boolean}\n */\nvar isEscapePossible = function(blocked, source, target) {\n    \n};"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "function isEscapePossible(blocked: number[][], source: number[], target: number[]): boolean {\n    \n};"}, {"value": "php", "text": "PHP", "defaultCode": "class Solution {\n\n    /**\n     * @param Integer[][] $blocked\n     * @param Integer[] $source\n     * @param Integer[] $target\n     * @return Boolean\n     */\n    function isEscapePossible($blocked, $source, $target) {\n        \n    }\n}"}, {"value": "swift", "text": "Swift", "defaultCode": "class Solution {\n    func isEscapePossible(_ blocked: [[Int]], _ source: [Int], _ target: [Int]) -> Bool {\n        \n    }\n}"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class Solution {\n    fun isEscapePossible(blocked: Array<IntArray>, source: IntArray, target: IntArray): Boolean {\n        \n    }\n}"}, {"value": "dart", "text": "Dart", "defaultCode": "class Solution {\n  bool isEscapePossible(List<List<int>> blocked, List<int> source, List<int> target) {\n    \n  }\n}"}, {"value": "golang", "text": "Go", "defaultCode": "func isEscapePossible(blocked [][]int, source []int, target []int) bool {\n    \n}"}, {"value": "ruby", "text": "Ruby", "defaultCode": "# @param {Integer[][]} blocked\n# @param {Integer[]} source\n# @param {Integer[]} target\n# @return {Boolean}\ndef is_escape_possible(blocked, source, target)\n    \nend"}, {"value": "scala", "text": "Scala", "defaultCode": "object Solution {\n    def isEscapePossible(blocked: Array[Array[Int]], source: Array[Int], target: Array[Int]): Boolean = {\n        \n    }\n}"}, {"value": "rust", "text": "Rust", "defaultCode": "impl Solution {\n    pub fn is_escape_possible(blocked: Vec<Vec<i32>>, source: Vec<i32>, target: Vec<i32>) -> bool {\n        \n    }\n}"}, {"value": "racket", "text": "Racket", "defaultCode": "(define/contract (is-escape-possible blocked source target)\n  (-> (listof (listof exact-integer?)) (listof exact-integer?) (listof exact-integer?) boolean?)\n  )"}, {"value": "erlang", "text": "Erlang", "defaultCode": "-spec is_escape_possible(Blocked :: [[integer()]], Source :: [integer()], Target :: [integer()]) -> boolean().\nis_escape_possible(Blocked, Source, Target) ->\n  ."}, {"value": "elixir", "text": "Elixir", "defaultCode": "defmodule Solution do\n  @spec is_escape_possible(blocked :: [[integer]], source :: [integer], target :: [integer]) :: boolean\n  def is_escape_possible(blocked, source, target) do\n    \n  end\nend"}, {"value": "cangjie", "text": "Cangjie", "defaultCode": "class Solution {\n    func isEscapePossible(blocked: Array<Array<Int64>>, source: Array<Int64>, target: Array<Int64>): Bool {\n\n    }\n}"}]}