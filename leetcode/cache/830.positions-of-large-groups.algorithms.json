{"id": 830, "fid": "830", "name": "较大分组的位置", "slug": "positions-of-large-groups", "link": "https://leetcode.cn/problems/positions-of-large-groups/description/", "percent": 0, "level": "Easy", "category": "algorithms", "en_name": "Positions of Large Groups", "cn_name": "较大分组的位置", "desc": "<p>在一个由小写字母构成的字符串 <code>s</code> 中，包含由一些连续的相同字符所构成的分组。</p>\n\n<p>例如，在字符串 <code>s = \"abbxxxxzyy\"</code> 中，就含有 <code>\"a\"</code>, <code>\"bb\"</code>, <code>\"xxxx\"</code>, <code>\"z\"</code> 和 <code>\"yy\"</code> 这样的一些分组。</p>\n\n<p>分组可以用区间 <code>[start, end]</code> 表示，其中 <code>start</code> 和 <code>end</code> 分别表示该分组的起始和终止位置的下标。上例中的 <code>\"xxxx\"</code> 分组用区间表示为 <code>[3,6]</code> 。</p>\n\n<p>我们称所有包含大于或等于三个连续字符的分组为 <strong>较大分组</strong> 。</p>\n\n<p>找到每一个 <strong>较大分组</strong> 的区间，<strong>按起始位置下标递增顺序排序后</strong>，返回结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abbxxxxzzy\"\n<strong>输出：</strong>[[3,6]]\n<strong>解释</strong><strong>：</strong><code>\"xxxx\" 是一个起始于 3 且终止于 6 的较大分组</code>。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abc\"\n<strong>输出：</strong>[]\n<strong>解释：</strong>\"a\",\"b\" 和 \"c\" 均不是符合要求的较大分组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcdddeeeeaabbbcd\"\n<strong>输出：</strong>[[3,5],[6,9],[12,14]]\n<strong>解释：</strong>较大分组为 \"ddd\", \"eeee\" 和 \"bbb\"</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aba\"\n<strong>输出：</strong>[]\n</pre>\n \n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 1000</code></li>\n\t<li><code>s</code> 仅含小写英文字母</li>\n</ul>\n", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "class Solution {\npublic:\n    vector<vector<int>> largeGroupPositions(string s) {\n        \n    }\n};"}, {"value": "java", "text": "Java", "defaultCode": "class Solution {\n    public List<List<Integer>> largeGroupPositions(String s) {\n        \n    }\n}"}, {"value": "python", "text": "Python", "defaultCode": "class Solution(object):\n    def largeGroupPositions(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[int]]\n        \"\"\"\n        "}, {"value": "python3", "text": "Python3", "defaultCode": "class Solution:\n    def largeGroupPositions(self, s: str) -> List[List[int]]:\n        "}, {"value": "c", "text": "C", "defaultCode": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** largeGroupPositions(char* s, int* returnSize, int** returnColumnSizes) {\n    \n}"}, {"value": "csharp", "text": "C#", "defaultCode": "public class Solution {\n    public IList<IList<int>> LargeGroupPositions(string s) {\n        \n    }\n}"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "/**\n * @param {string} s\n * @return {number[][]}\n */\nvar largeGroupPositions = function(s) {\n    \n};"}, {"value": "typescript", "text": "TypeScript", "defaultCode": "function largeGroupPositions(s: string): number[][] {\n    \n};"}, {"value": "php", "text": "PHP", "defaultCode": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer[][]\n     */\n    function largeGroupPositions($s) {\n        \n    }\n}"}, {"value": "swift", "text": "Swift", "defaultCode": "class Solution {\n    func largeGroupPositions(_ s: String) -> [[Int]] {\n        \n    }\n}"}, {"value": "kotlin", "text": "Kotlin", "defaultCode": "class Solution {\n    fun largeGroupPositions(s: String): List<List<Int>> {\n        \n    }\n}"}, {"value": "dart", "text": "Dart", "defaultCode": "class Solution {\n  List<List<int>> largeGroupPositions(String s) {\n    \n  }\n}"}, {"value": "golang", "text": "Go", "defaultCode": "func largeGroupPositions(s string) [][]int {\n    \n}"}, {"value": "ruby", "text": "Ruby", "defaultCode": "# @param {String} s\n# @return {Integer[][]}\ndef large_group_positions(s)\n    \nend"}, {"value": "scala", "text": "Scala", "defaultCode": "object Solution {\n    def largeGroupPositions(s: String): List[List[Int]] = {\n        \n    }\n}"}, {"value": "rust", "text": "Rust", "defaultCode": "impl Solution {\n    pub fn large_group_positions(s: String) -> Vec<Vec<i32>> {\n        \n    }\n}"}, {"value": "racket", "text": "Racket", "defaultCode": "(define/contract (large-group-positions s)\n  (-> string? (listof (listof exact-integer?)))\n  )"}, {"value": "erlang", "text": "Erlang", "defaultCode": "-spec large_group_positions(S :: unicode:unicode_binary()) -> [[integer()]].\nlarge_group_positions(S) ->\n  ."}, {"value": "elixir", "text": "Elixir", "defaultCode": "defmodule Solution do\n  @spec large_group_positions(s :: String.t) :: [[integer]]\n  def large_group_positions(s) do\n    \n  end\nend"}, {"value": "cangjie", "text": "Cangjie", "defaultCode": "class Solution {\n    func largeGroupPositions(s: String): ArrayList<ArrayList<Int64>> {\n\n    }\n}"}]}