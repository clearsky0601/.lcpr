# LCPR 项目代码生成提示词

## 📋 项目规范

当你为这个LeetCode刷题项目生成代码时，请遵循以下规范：

### 1. 目录结构

```
.lcpr/
├── py/                          # Python题目
│   ├── {题目编号}.{题目名称}/
│   │   ├── solution.py          # 第一个解法（推荐方法）
│   │   ├── solution2-{方法名}.py # 第二个解法
│   │   ├── solution3-{方法名}.py # 第三个解法
│   │   └── README.md            # 题目说明和解题思路
│   └── ...
├── cpp/                         # C++题目
└── ...
```

### 2. 文件命名规范

- **第一个解法**：`solution.py`（或对应语言的扩展名）
- **后续解法**：`solution2-{方法名}.py`
  - `solution2-brute-force.py` - 暴力解法
  - `solution2-two-pointer.py` - 双指针
  - `solution2-hashmap.py` - 哈希表
  - `solution2-dp.py` - 动态规划
  - `solution2-dfs.py` - 深度优先搜索
  - `solution2-bfs.py` - 广度优先搜索
  - `solution2-iterative-dfs.py` - 迭代DFS
  - `solution2-iterative-bfs.py` - 迭代BFS
  - `solution2-recursive.py` - 递归
  - `solution2-iterative.py` - 迭代

### 3. 代码格式要求

#### 3.1 文件头部

```python
# @lc app=leetcode.cn id={题目编号} lang=python3
# @lcpr version=
#
# [{题目编号}] {题目名称}
#

# @lcpr-template-start

# @lcpr-template-end
# @lc code=start
# Definition for a binary tree node.  # 如果有需要
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from typing import Optional  # 或其他必要的导入

class Solution:
    def functionName(self, ...):
        """
        方法描述：{方法名称}
        时间复杂度：O(?)
        空间复杂度：O(?)
        
        思路：
        1. 关键点1
        2. 关键点2
        3. 关键点3
        """
        # 代码实现
        pass
# @lc code=end

#
# @lcpr case=start
# {测试用例1}
# @lcpr case=end

# @lcpr case=start
# {测试用例2}
# @lcpr case=end
```

#### 3.2 代码注释要求

- **函数注释**：必须包含方法描述、时间/空间复杂度、思路说明
- **关键步骤注释**：在重要逻辑处添加注释
- **变量命名**：使用有意义的变量名，必要时添加注释

```python
def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
    """
    方法1：递归DFS（深度优先搜索）
    时间复杂度：O(min(m, n))，其中m和n分别是两棵树的节点数
    空间复杂度：O(min(m, n))，递归栈的深度
    
    思路：
    1. 如果两个节点都为空，返回True
    2. 如果只有一个节点为空，返回False
    3. 如果两个节点值不同，返回False
    4. 递归比较左子树和右子树
    """
    # 两个节点都为空
    if not p and not q:
        return True
    
    # 只有一个节点为空
    if not p or not q:
        return False
    
    # 节点值不同
    if p.val != q.val:
        return False
    
    # 递归比较左右子树
    return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
```

### 4. 多解法生成规范

当用户要求"用不同的方法解决这道题"时：

1. **至少提供3-4种不同的解法**
2. **优先顺序**：
   - 方法1：最常见/最优解法（放在 `solution.py`）
   - 方法2：迭代版本（如果方法1是递归）
   - 方法3：其他思路（如BFS、DFS的不同实现）
   - 方法4：特殊方法（如序列化、数学方法等）

3. **每种解法需要**：
   - 独立文件
   - 完整的代码注释
   - 时间/空间复杂度分析
   - 思路说明

### 5. README.md 格式

每个题目文件夹必须包含 `README.md`，格式如下：

```markdown
# {题目编号}. {题目名称}

## 题目链接

https://leetcode.cn/problems/{slug}/

## 难度

Easy / Medium / Hard

## 题目描述

（简要描述题目的要求和约束）

## 解法

### 方法1：{方法名称}（推荐⭐）

- 文件：`solution.py`
- 时间复杂度：O(?)
- 空间复杂度：O(?)
- 思路：
  - 关键点1
  - 关键点2
- 优点：
  - 优点1
  - 优点2
- 代码要点：
  ```python
  # 关键代码片段
  ```

### 方法2：{方法名称}

- 文件：`solution2-{方法名}.py`
- 时间复杂度：O(?)
- 空间复杂度：O(?)
- 思路：
  - ...
- 优缺点：
  - 优点：...
  - 缺点：...

## 总结

- **最佳解法**：方法1（原因）
- **适用场景**：
  - 方法1：...
  - 方法2：...

## 复杂度对比

| 方法 | 时间复杂度 | 空间复杂度 | 代码复杂度 |
|------|-----------|-----------|-----------|
| 方法1 | O(?) | O(?) | ⭐⭐ |
| 方法2 | O(?) | O(?) | ⭐⭐⭐ |

## 相关题目

- [题目编号. 题目名称](链接)
```

### 6. 代码质量标准

1. **可读性**：
   - 变量名清晰
   - 逻辑清晰
   - 注释充分

2. **正确性**：
   - 通过所有测试用例
   - 处理边界情况
   - 考虑空值/空集合

3. **效率**：
   - 分析时间复杂度
   - 分析空间复杂度
   - 优化不必要的操作

4. **完整性**：
   - 包含必要的导入
   - 包含测试用例
   - 包含README说明

### 7. 常见解法模板

#### 递归模板
```python
def recursive(self, ...):
    """
    递归解法
    时间复杂度：O(?)
    空间复杂度：O(?) # 递归栈深度
    """
    # 基础情况
    if base_case:
        return result
    
    # 递归情况
    return self.recursive(...)
```

#### 迭代模板
```python
def iterative(self, ...):
    """
    迭代解法
    时间复杂度：O(?)
    空间复杂度：O(?)
    """
    stack/queue = [initial]
    while stack/queue:
        # 处理逻辑
        pass
    return result
```

#### 双指针模板
```python
def two_pointer(self, ...):
    """
    双指针解法
    时间复杂度：O(n)
    空间复杂度：O(1)
    """
    left, right = 0, len(nums) - 1
    while left < right:
        # 处理逻辑
        pass
    return result
```

#### 哈希表模板
```python
def hashmap(self, ...):
    """
    哈希表解法
    时间复杂度：O(n)
    空间复杂度：O(n)
    """
    hashmap = {}
    for item in items:
        # 处理逻辑
        pass
    return result
```

### 8. 测试用例规范

每个解法文件必须包含至少3个测试用例：

```python
# @lcpr case=start
# {标准测试用例}
# @lcpr case=end

# @lcpr case=start
# {边界测试用例}
# @lcpr case=end

# @lcpr case=start
# {特殊情况测试用例}
# @lcpr case=end
```

### 9. 特殊要求

1. **中文注释**：所有注释和文档使用中文
2. **类型提示**：Python代码使用类型提示（`from typing import Optional, List`等）
3. **代码风格**：遵循PEP 8规范
4. **文件组织**：一个解法一个文件，不要混在一起

### 10. 示例：完整的多解法实现

参考 `py/100.same-tree/` 目录：
- `solution.py` - 递归DFS（推荐）
- `solution2-iterative-dfs.py` - 迭代DFS
- `solution3-iterative-bfs.py` - 迭代BFS
- `solution4-serialize.py` - 序列化比较
- `README.md` - 详细说明

## 🎯 使用指南

当你需要生成代码时，请：

1. ✅ **确认题目信息**：题目编号、名称、难度
2. ✅ **生成主解法**：`solution.py`（最优/最常见方法）
3. ✅ **生成其他解法**：至少2-3个不同思路的解法
4. ✅ **创建README**：包含所有解法的详细说明
5. ✅ **添加测试用例**：每个文件至少3个测试用例
6. ✅ **检查代码质量**：注释、复杂度分析、可读性

## 📝 快速检查清单

生成代码后，请检查：

- [ ] 文件命名符合规范
- [ ] 代码注释完整（方法说明、复杂度、思路）
- [ ] 包含必要的导入语句
- [ ] 包含至少3个测试用例
- [ ] 处理了边界情况
- [ ] README.md 包含所有解法说明
- [ ] 代码格式规范（PEP 8）
- [ ] 类型提示正确

---

**遵循这些规范，确保代码质量和项目一致性！**

